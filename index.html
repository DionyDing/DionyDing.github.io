<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>D_d</title>
  <meta name="author" content="D_d" />

  
  <meta name="description" content="这里是丁丁的博客" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  
  <meta property="og:site_name" content="D_d" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  <link href="http://o6yoa3nwp.bkt.clouddn.com/favicon.ico" rel="icon" />
 

  <link rel="alternate" href="/atom.xml" title="D_d" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><br/><br/><br/><br/><br/><br/><br/>
<div class="alignleft1">
  <h1><a href="/">D_d</a></h1><br/>
  <h2><a href="/">——Welcome to D_d&#39;s Blog!——</a></h2><br/>
</div>
<nav id="main-nav" class="alignright1">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/">关于生活</a></li>
    
      <li><a href="/categories/technology">技术</a></li>
    
      <li><a href="/categories/technology/javascript">js</a></li>
    
      <li><a href="/categories/technology/css">HTML&amp;CSS</a></li>
    
      <li><a href="/categories/plan">哈哈哈计划赶不上变化</a></li>
    
  </ul>
</nav>
<br/><br/></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-14T14:13:05.327Z"><a href="/2016/06/14/《javascript权威指南》学习笔记（9）/">2016-06-14</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/14/《javascript权威指南》学习笔记（9）/"></a></h1>
  

    </header>
    <div class="entry">
      
        <hr>
<p>title: 《javascript权威指南》学习笔记（9）<br>date: 2016-06-14 22:05:20<br>categories: [technology,javascript]</p>
<h2 id="tags-javascript学习笔记"><a href="#tags-javascript学习笔记" class="headerlink" title="tags: [javascript学习笔记]"></a>tags: [javascript学习笔记]</h2><h1 id="event事件对象篇"><a href="#event事件对象篇" class="headerlink" title="event事件对象篇"></a>event事件对象篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<h2 id="event代表事件状态，例如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态等"><a href="#event代表事件状态，例如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态等" class="headerlink" title="event代表事件状态，例如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态等"></a>event代表事件状态，例如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态等</h2><p><div style="color:red;font-size:20px;">event对象只在事件发生的过程中才有效！</div></p>
<h3 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h3><ul>
<li>事件是Web浏览器通知应用程序发生了什么事情</li>
<li>提及事件必须指明事件类型和目标<br>事件类型：说明发生了什么类型事件的字符串<br>时间目标：发生事件的对象或与之相关的对象</li>
<li>事件传播的三个阶段：<ul>
<li>捕获：目标处理程序调用之前，沿DOM树向下，从外向内捕获</li>
<li>目标对象本身的事件处理程序调用</li>
<li>冒泡：文档元素上发生某类型事件时会沿DOM树向上冒泡，当前DOM直到&lt;body&gt;,再到document，再到window<h3 id="注册事件处理程序"><a href="#注册事件处理程序" class="headerlink" title="注册事件处理程序"></a>注册事件处理程序</h3></li>
</ul>
</li>
<li>addEventListener(‘eventType’,function,<del>bool</del>):三个参数为事件类型，发生时执行的函数，是否为捕获阶段（可省略，默认false）<br>IE9前使用attachEvent(‘oneventType’,function);（tips:这里function中this指向window，addEventListener()中this指向事件目标）<br>可为同一事件注册多个函数，执行时会按注册顺序调用；<br>参数相同的情况下多次调用addEventListener()只注册一次</li>
<li>通过JS中对应属性设置：事件处理程序属性名称由”on”+”eventType”组成，全部小写</li>
<li>通过HTML属性设置：事件处理程序属性名称由”on”+”eventType”组成，全部小写。但为保持内容与行为分离，不应采用这种方式<h3 id="事件移除与取消"><a href="#事件移除与取消" class="headerlink" title="事件移除与取消"></a>事件移除与取消</h3></li>
<li>移除：removeEventListener(‘eventType’,function,<del>bool</del>)参数必须和注册时相同</li>
<li>设置HTML属性注册事件处理程序，将返回值置为false，浏览器会取消默认行为，但这只对属性注册的程序有效</li>
<li>取消事件默认行为：preventDefault()</li>
<li>阻止事件传播：stopPropagation(),可在传播期间任何时间调用<br>IE9以下不支持，通过将cancelBuble置为true阻止<h3 id="事件处理程序执行环境为其定义时的作用域，而不是调用时的作用域；但HTML属性中的事件处理程序会被转为能存取全局变量的顶级函数"><a href="#事件处理程序执行环境为其定义时的作用域，而不是调用时的作用域；但HTML属性中的事件处理程序会被转为能存取全局变量的顶级函数" class="headerlink" title="事件处理程序执行环境为其定义时的作用域，而不是调用时的作用域；但HTML属性中的事件处理程序会被转为能存取全局变量的顶级函数"></a>事件处理程序执行环境为其定义时的作用域，而不是调用时的作用域；但HTML属性中的事件处理程序会被转为能存取全局变量的顶级函数</h3><h3 id="事件处理程序的调用顺序"><a href="#事件处理程序的调用顺序" class="headerlink" title="事件处理程序的调用顺序"></a>事件处理程序的调用顺序</h3></li>
<li>通过JS对应属性及HTML属性注册的程序优先调用</li>
<li>addEventListener()按注册顺序调用</li>
<li>attachEvent()可能按任意顺序调用<h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3></li>
<li>三个阶段：捕获、事件处理程序调用、冒泡</li>
<li>当需要在大量单独的文档元素上注册处理程序时，可在其共同的祖先元素上注册</li>
<li>特殊冒泡行为：<ul>
<li>focus,blur,scroll不冒泡</li>
<li>load冒泡至document对象停止，文档全部加载完才会冒泡至window对象</li>
</ul>
</li>
<li>捕获常用于处理鼠标拖放，因为拖放目标不能是元素内部的子元素<h3 id="文档加载事件"><a href="#文档加载事件" class="headerlink" title="文档加载事件"></a>文档加载事件</h3></li>
<li>load:直到文档和所有图片加载完毕才发生（load发生前触发脚本可以提升web应用启动时间）</li>
<li>DOMContentLoaded：文档加载完毕且所有延迟脚本执行完毕触发</li>
<li>readystatechange：状态改变触发，在load事件前触发<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3></li>
<li>click：按下并释放鼠标按键时触发</li>
<li>contextmenu：单击鼠标右键上下文菜单即将出现时触发，可取消默认行为</li>
<li>dbclick：双击鼠标触发</li>
<li>mousedown：按下鼠标按键时触发</li>
<li>mouseup：释放鼠标按键时触发</li>
<li>mouseout：离开元素时触发（mouseleave为不冒泡的mouseout）</li>
<li>mouseover：进入元素悬停时触发（mouseenter为不冒泡的mouseover）</li>
<li>mousemove：移动鼠标时触发</li>
<li>tips：<br>传递给鼠标事件的event对象有clientX,clientY属性，指示鼠标位置的窗口坐标<br>event对象有altkey,ctrlkey,shiftkey,metakey等属性指定鼠标事件发生时该键有没有按下<h3 id="鼠标滚轮事件"><a href="#鼠标滚轮事件" class="headerlink" title="鼠标滚轮事件"></a>鼠标滚轮事件</h3></li>
<li>mousewheel:默认滚动或缩放文档，可阻止默认操作<br>传递给事件处理程序的事件对象event有wheelDelta属性，指定滚轮有多远<br>Firefox中用DOMMouseScroll取代mousewheel，用detail取代wheelDelta<h3 id="文本事件"><a href="#文本事件" class="headerlink" title="文本事件"></a>文本事件</h3></li>
<li>keydown:按下键盘（包括辅助键、功能键、字母数字键）</li>
<li>keypress:keydown产生可打印字符时，在keydown和keyup之间触发，文本真正插入前触发，表输入单个字符（可能需用string.fromCharCode()转为字符串才生效）</li>
<li>keyup:键盘释放（包括辅助键、功能键、字母数字键）</li>
<li>textinput：无论何时用户输入文本都会触发，不管来源（有兼容性问题）</li>
<li>相关event对象有keycode属性，指定按下的键是哪个<ul>
<li>可打印字符keycode值为unicode编码</li>
<li>字母键keycode值总为大写</li>
</ul>
</li>
<li>相关event对象有altkey,ctrlkey,shiftkey,metakey属性，事件发生时对应辅助键按下值为true<h3 id="事件处理程序定义时要传入参数e代表event对象！"><a href="#事件处理程序定义时要传入参数e代表event对象！" class="headerlink" title="事件处理程序定义时要传入参数e代表event对象！"></a>事件处理程序定义时要传入参数e代表event对象！</h3><h3 id="event对象的target属性：触发事件的元素（IE下为srcElement属性）"><a href="#event对象的target属性：触发事件的元素（IE下为srcElement属性）" class="headerlink" title="event对象的target属性：触发事件的元素（IE下为srcElement属性）"></a>event对象的target属性：触发事件的元素（IE下为srcElement属性）</h3><h3 id="event对象的currentTarget属性：事件绑定的节点"><a href="#event对象的currentTarget属性：事件绑定的节点" class="headerlink" title="event对象的currentTarget属性：事件绑定的节点"></a>event对象的currentTarget属性：事件绑定的节点</h3><h3 id="以上两者在事件委托时不同（事件委托-事件代理：利用事件会冒泡到父节点，通过父节点监听事件，再判断是父节点下哪个节点触发，做相应处理）"><a href="#以上两者在事件委托时不同（事件委托-事件代理：利用事件会冒泡到父节点，通过父节点监听事件，再判断是父节点下哪个节点触发，做相应处理）" class="headerlink" title="以上两者在事件委托时不同（事件委托/事件代理：利用事件会冒泡到父节点，通过父节点监听事件，再判断是父节点下哪个节点触发，做相应处理）"></a>以上两者在事件委托时不同（事件委托/事件代理：利用事件会冒泡到父节点，通过父节点监听事件，再判断是父节点下哪个节点触发，做相应处理）</h3>一个事件委托的例子：<pre><br>window.onload=function (){<br>var oUL=document.getElementById(‘ul’);<br>oUL.addEventListener(‘mouseover’,overFun,false);<br>oUL.addEventListener(‘mouseout’,outFun,false);<br>function overFun(e){<br>  var e=e||window.e;<br>  var target=e.target||e.srcElement  //兼容IE<br>  if(target.nodeName.toLowerCase()==’li’){<pre><code>target.style.background=&apos;red&apos;;
</code></pre>  }<br>}<br>function outFun(e){<pre><code>var e=e||window.e;
var target=e.target||e.srcElement  //兼容IE
if(target.nodeName.toLowerCase()==&apos;li&apos;){
  target.style.background=&apos;yellowgreen&apos;;
}
</code></pre>  }<br>}<br></pre></li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-14T14:05:11.000Z"><a href="/2016/06/14/《javascript权威指南》学习笔记（8）/">2016-06-14</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/14/《javascript权威指南》学习笔记（8）/">《javascript权威指南》学习笔记（8）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="脚本化CSS篇"><a href="#脚本化CSS篇" class="headerlink" title="脚本化CSS篇"></a>脚本化CSS篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<h3 id="一些CSS内容"><a href="#一些CSS内容" class="headerlink" title="一些CSS内容"></a>一些CSS内容</h3><ul>
<li>font复合属性：包括font-style,font-weight,font-variant,font-size/line-height,font-family;可忽略其中任意属性，不同属性空格分隔，同一属性的多值逗号分隔</li>
<li>text-transform:uppercase/lowercase/capitalize/none/inherit,设置文本大小写</li>
<li>box-sizing:border-box/content-box/inherit,宽高指定的范围</li>
<li>overflow:visible(溢出可绘制)/hidden(裁剪隐藏溢出)/scroll(一直显示滚动条，溢出滚动条查看)/auto(内容溢出时显示滚动条)</li>
<li><p>clip:裁剪绝对定位的元素（必有position:absolute!），值rect(top right bottom left)(矩形框中内容可见)/auto(不剪裁)<br><img src="http://o6yo3ducz.bkt.clouddn.com/clip%E5%B1%9E%E6%80%A7rect%E7%A4%BA%E6%84%8F%E5%9B%BE.png" title="clip属性rect值示意图" width="290px"></p>
</li>
<li><p>透明度：opacity:0~1;为兼容IE设置filter:alpha(opacity=0~100)</p>
</li>
<li>CSS3有支持计算的属性：cal(val)，但存在一些兼容性问题，eg:<code>width:cal(50%-12px);</code></li>
<li>对已定位元素，只设置left，right可隐性指定宽度，但同时设置left，width，right不合理时，width会覆盖right（top,height,bottom同理，但一般不指定高度，由内容撑起）</li>
<li>对定位而言，left,top基于左上角定位，bottom,right基于右下角定位，指容器border内侧到定位元素border外侧的距离</li>
<li>z-index相当于z轴维度，默认为0，可正可负，正显示于文档流之上，负显示于文档流之下，值越大越靠上，相同值按文档流次序显示；只对有定位元素生效，无定位（position:static）元素无效，<span style="red">且只对兄弟元素应用堆叠效果</span></li>
<li>通过@font-face可下载并使用自定义字体</li>
<li>text-shadow,box-shadow属性可用position,left,top,z-index:-1,background-color等属性模拟<h3 id="脚本化的CSS（xxx-style-xxx更改的为内联样式，即直接在HTML元素的style属性下更改）"><a href="#脚本化的CSS（xxx-style-xxx更改的为内联样式，即直接在HTML元素的style属性下更改）" class="headerlink" title="脚本化的CSS（xxx.style.xxx更改的为内联样式，即直接在HTML元素的style属性下更改）"></a>脚本化的CSS（xxx.style.xxx更改的为内联样式，即直接在HTML元素的style属性下更改）</h3></li>
<li>JS中style属性的值本质为一个CSSStyleDeclaration对象，形式为字符串形式</li>
<li>含连字符的属性在JS的脚本化CSS中要去掉连字符，连字符间的单词首字母要大写，eg:font-weight-&gt;fontWeight<br>Float为JS保留字，采用CSSFloat代替；class为JS保留字，用className代替</li>
<li>定位属性的值在脚本化CSS中要包含px等单位</li>
<li>xxx.style.cssText可以查询<strong>内联样式</strong></li>
<li>HTML元素有方法<code>setAttribute（&#39;attr&#39;,&#39;value&#39;）</code>和<code>getAttribute（&#39;attr&#39;）</code>用来设置和获取属性</li>
<li>计算样式：是一组属性值，经过结合内联样式和链接样式等中所有可用样式得到显示时实际所用的属性值<br>只读，不可写；值为非百分比的绝对值；不计算复合样式；<br>使用：<code>window.getComputedStyle(element,null/&#39;:after&#39;/&#39;:firstline&#39;…);</code></li>
<li>H5定义了classList属性，解决多类名问题。其中有add(),remove()等方法添加删除类名；还有contains()检测是否包含类名；及toggle()不存在则添加存在则删除类名；</li>
<li>document.stylesheets:只读类数组对象，包括&lt;link&gt;和&lt;style&gt;下的样式表<br><span style="color:red;">有disable属性，值为true会被浏览器忽略</span><br><code>document.stylesheets[i].cssRules[]</code>对象包含样式表所有规则，IE中为<code>document.stylesheets[i].Rules[]</code></li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-06T14:09:42.000Z"><a href="/2016/06/06/《javascript权威指南》学习笔记（7）/">2016-06-06</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/06/《javascript权威指南》学习笔记（7）/">《javascript权威指南》学习笔记（7）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="document对象篇"><a href="#document对象篇" class="headerlink" title="document对象篇"></a>document对象篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<h3 id="window对象的document属性引用了Document对象，document对象表示窗口的内容，它是一个巨大的API中的核心对象，叫做文档对象模型（Document-Object-Model）"><a href="#window对象的document属性引用了Document对象，document对象表示窗口的内容，它是一个巨大的API中的核心对象，叫做文档对象模型（Document-Object-Model）" class="headerlink" title="window对象的document属性引用了Document对象，document对象表示窗口的内容，它是一个巨大的API中的核心对象，叫做文档对象模型（Document Object Model）"></a>window对象的document属性引用了Document对象，document对象表示窗口的内容，它是一个巨大的API中的核心对象，叫做文档对象模型（Document Object Model）</h3><h3 id="选取文档元素"><a href="#选取文档元素" class="headerlink" title="选取文档元素"></a>选取文档元素</h3><ul>
<li>通过ID：<code>document.getElementById(&#39;xxx&#39;)</code></li>
<li>通过CSS类：<code>document.getElementsByClassName(&#39;xxx&#39;)</code>，返回同类名的NodeList对象，可传入多个类名以空格分隔，具体到选中某一个使用<code>document.getElementsByClassName(&#39;xxx&#39;)[i]</code></li>
<li>通过标签名：<code>document.getElementsByTagName(&#39;xxx&#39;)[i]</code>，可传入星号通配符’*’</li>
<li>通过名字：<code>document.getElementsByName(&#39;xxx&#39;)[i]</code>（name属性只在少数HTML中有效，如：表单元素、&lt;img&gt;、&lt;iframe&gt;）</li>
<li>通过CSS选择器：借助querySelectorAll方法<h3 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h3>Document对象的Element对象和文档中表示文本的Text对象都是Node对象，Node对象有以下重要属性</li>
<li>作为节点树：<ul>
<li>parentNode：当前节点的父节点</li>
<li>childNodes:子节点，类数组对象，NodeList对象，具体到某个子节点childNodes[i]</li>
<li>firstChild,lastChild:第一个/最后一个子节点（无返回Null）eg：&lt;p&gt;123&lt;这里<code>document.getElementByTagName(&#39;p&#39;)[0].firstChild</code>为Text节点</li>
<li>nextSibling，previousSibling:下一个/上一个兄弟节点(使用时注意每两个节点间有一个空节点)</li>
<li>length：节点长度（如;Node.childNodes.length）</li>
<li>nodeType：节点类型（9为document节点，1为Element节点…Text节点为无标签的文字节点，comment节点为注释节点）</li>
<li>nodeValue：文本内容</li>
<li>nodeName：返回大写形式的元素标签名</li>
</ul>
</li>
<li>作为元素树：<ul>
<li>firstElementChild,lastElementChild:代表Element的首个子节点/最后一个子节点</li>
<li>nextElementSibling，previousElementSibling:代表兄弟Element</li>
<li>children:子Element</li>
<li>childElementCount:子Element数量<h3 id="HTML元素属性（HTML属性名大、小写不敏感，但JS属性名大、小写敏感）"><a href="#HTML元素属性（HTML属性名大、小写不敏感，但JS属性名大、小写敏感）" class="headerlink" title="HTML元素属性（HTML属性名大、小写不敏感，但JS属性名大、小写敏感）"></a>HTML元素属性（HTML属性名大、小写不敏感，但JS属性名大、小写敏感）</h3></li>
</ul>
</li>
<li>数据集属性：这里非标准属性，使用的代价是文档不再为合法有效的HTML，针对这点，H5解决方案为：以”data-“为前缀的小写属性是合法的，使用dataset属性设定（dataset.x对应data-x），这样不会在合法性上让步<ul>
<li><code>Node.getAttribute(&#39;xxx&#39;)</code>:查询非标准HTML属性，这里返回字符串，若需要数值类型要强制转换</li>
<li><code>Node.setAttribute(&#39;attribute&#39;,&#39;value&#39;)</code>:设置非标准HTML属性</li>
<li><code>Node.hasAttribute(&#39;xxx&#39;)</code>:判断属性名是否存在</li>
<li><code>Node.removeAttribute(&#39;xxx&#39;)</code>:删除属性</li>
</ul>
</li>
<li>Element对象有attributes类数组，eg:<code>Element.attributes[i]</code>/<code>Element.attributes.width</code>/<code>Element.attributes[onload]</code><h3 id="元素的内容"><a href="#元素的内容" class="headerlink" title="元素的内容"></a>元素的内容</h3></li>
<li>Element的innerHTML返回元素的内容（通常innerHTML效率非常高，但用‘+=’追加文本效率低下，因为它既要序列化又要解析）</li>
<li>H5有outerHTML属性，返回被查询元素的开头和结尾标签（存在一些兼容性问题）</li>
<li>textContent：不适于IE，返回返回所有后代Text节点的串联纯文本<br>innerText：只适用于IE，返回纯文本内容，不返回&lt;script&gt;下内容会忽略多余空格<h3 id="创建、插入、删除节点"><a href="#创建、插入、删除节点" class="headerlink" title="创建、插入、删除节点"></a>创建、插入、删除节点</h3></li>
<li>创建：<ul>
<li><code>document.createElement(&#39;标签名&#39;);</code></li>
<li><code>document.createTextNode(&#39;content&#39;)</code>:创建Text节点；</li>
<li><code>Node.cloneNode(bool)</code>:true为复制所有后代节点；false为浅复制（默认）</li>
</ul>
</li>
<li>插入节点：<ul>
<li><code>Node.appendChild(a)</code>:将a节点插入为Node节点的最后一个子节点</li>
<li><code>Node.insertBefore(new,old)</code>:<span style="color:red">Node为待插入节点的父节点，在父节点上调用该方法！</span>在old节点前插入New节点</li>
<li>Tips:<span style="color:red">将文档中已存在的节点重新插入，会自动从当前位置删除该节点并在新位置插入！</span></li>
</ul>
</li>
<li>删除节点：<ul>
<li><code>Node.removeChild(a)</code>:在Node节点上删除其子节点a</li>
<li><code>Node.replaceChild(new,old)</code>:<span style="color:red">Node为待替换节点的父节点，在父节点上调用该方法！</span>以new节点代替old节点</li>
</ul>
</li>
<li>DocumentFragment:<ul>
<li>一种特殊的Node，类似于文档片段，使一组节点被当做一个节点看待，创建并插入多节点时性能更佳，它是独立的，不是其他任何文档的一部分，其ParentNode为Null，可以有任意多子节点</li>
<li>创建：<code>document.createDocumentFragment()</code></li>
<li>插入和删除采用<code>appendChild(a)</code>，<code>insertBefore(new,old)</code>，<code>removeChild(a)</code>，<code>replaceChild(new,old)</code>，<span style="color:red">操作的是DocumentFragment的子孙节点</span><h3 id="窗口坐标（元素位置以像素度量，右为X轴正向，下为Y轴正向）"><a href="#窗口坐标（元素位置以像素度量，右为X轴正向，下为Y轴正向）" class="headerlink" title="窗口坐标（元素位置以像素度量，右为X轴正向，下为Y轴正向）"></a>窗口坐标（元素位置以像素度量，右为X轴正向，下为Y轴正向）</h3></li>
</ul>
</li>
<li>文档坐标：原点为文档左上角<br>视口坐标（窗口坐标）：原点为不包括工具栏的浏览器窗口左上角（通常查询到的坐标为视口坐标）<br>二者相差滚动条偏移量（window对象的pageXoffset,pageYoffset返回滚动条偏移量，<body>节点或文档根节点document.documentElement的scrollTop,scrollLeft返回滚动条偏移量）</body></li>
<li>元素的尺寸、位置坐标(HTML元素的属性)<ul>
<li>offset前缀：对内联元素会生效<ul>
<li>offsetWidth,offsetHeight：包括border,padding,content的元素宽高</li>
<li>offsetLeft,offsetTop：文档坐标，基点为文档左上角，但对于已定位元素后代，会基于祖先元素定位</li>
<li>offsetParent：已定位元素相对的父元素</li>
</ul>
</li>
<li>client前缀：对内联元素总为0<ul>
<li>clientWidth,clientHeight:包括padding,content的元素宽高</li>
<li>clientLeft,clientTop:padding外边距到border内边距的距离，一般为border宽度，除非左或上有滚动条会包含滚动条宽度</li>
</ul>
</li>
<li>scroll前缀：<ul>
<li>scrollWidth,scrollHeight:包括padding,content的元素宽高，若有溢出内容包括溢出内容的宽高</li>
<li>scrollLeft,scrollTop:滚动条偏移量</li>
</ul>
</li>
</ul>
</li>
<li>滚动条<ul>
<li>window对象下，<code>scrollTo(x,y)</code>:滚动至(x,y)坐标处</li>
<li>window对象下，<code>scrollBy(x,y)</code>:相对参数，在当前滚动条基础上增加</li>
</ul>
</li>
<li>查询元素的几何尺寸<ul>
<li><code>element.getBoundingClientRect()</code>:无参数，返回一个对象，其left,top为左上角坐标，right,bottom为右下角坐标</li>
<li>Tips:该方法不是实时的，仅为当前静态情况</li>
</ul>
</li>
<li>window对象的innerWidth,innerHeight返回不含工具栏但包括滚动条的页面宽高<h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3></li>
<li>可通过<code>document.forms[i]</code>/<code>document.forms.elements[i]</code>访问</li>
<li>JS的Form对象有<code>submit()</code>和<code>reset()</code>方法，直接调用不会触发onsubmit,onreset事件</li>
<li>对onsubmit,onreset事件处理程序，可通过false取消动作，借此检查用户输入</li>
<li>下拉列表和下拉框<ul>
<li>&lt;select&gt;的type属性有单选select-one/多选select-multiple值，当multiple属性存在时，值为select-multiple</li>
<li>&lt;select&gt;的selectedIndex属性：返回被选中选项（若type为select-multiple失效）</li>
<li>通过options[i]的text,value属性返回对应文本内容及值</li>
<li>指定options.length会截断列表元素（大于length值的元素会被删除），options[i]=null;会删除当前元素并使后续元素移动填补空缺</li>
<li>添加列表元素可通过以下方式：（传统创建插入方式同样有效）<br><code>var a=new Option(&#39;text&#39;,&#39;value&#39;,defaultSelected,selected);</code>//后两个参数为布尔值<br><code>options[options.length]=a;</code><h3 id="查询选中的内容"><a href="#查询选中的内容" class="headerlink" title="查询选中的内容"></a>查询选中的内容</h3></li>
</ul>
</li>
<li><code>window.getselection()</code>方法可返回选中文本，但对&lt;textarea&gt;和&lt;input&gt;内部的文本会失效<h3 id="可编辑内容（以下存在兼容性问题，需要用一些编辑器组件）"><a href="#可编辑内容（以下存在兼容性问题，需要用一些编辑器组件）" class="headerlink" title="可编辑内容（以下存在兼容性问题，需要用一些编辑器组件）"></a>可编辑内容（以下存在兼容性问题，需要用一些编辑器组件）</h3></li>
<li>HTML元素有contentEditable属性使内容可编辑</li>
<li>Document有designMode属性，值为on可编辑，值为off不可编辑<h3 id="document-write-方法"><a href="#document-write-方法" class="headerlink" title="document.write()方法"></a><code>document.write()</code>方法</h3></li>
<li>解析文档时可用<code>document.write()</code>方法，可以在&lt;script&gt;顶层代码中调用<code>document.write()</code></li>
<li>若定义函数时没有调用而在事件处理程序中调用含<code>document.write()</code>的函数，结果可能会擦除当前文档</li>
<li>在defer和async属性存在的&lt;script&gt;中也不可调用</li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-06T03:25:10.000Z"><a href="/2016/06/06/《javascript权威指南》学习笔记（6）/">2016-06-06</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/06/《javascript权威指南》学习笔记（6）/">《javascript权威指南》学习笔记（6）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="window对象篇"><a href="#window对象篇" class="headerlink" title="window对象篇"></a>window对象篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><ul>
<li><code>setInterval(function,time)</code>,<code>clearInterval(some-setInterval)</code>:每隔time<strong>毫秒</strong>重复执行function,clearInterval为清除计时器</li>
<li><code>setTimeout(function,time)</code>,<code>clearTimeout(some-setTimeout)</code>:指定time<strong>毫秒</strong>后执行function(只执行一次),clearTimeout为清除计时器</li>
<li>Tips:<ul>
<li>设定计时器时传入的参数function不必调用，指定时间会自动调用；若传入了调用的function会每次都返回执行的结果！！！</li>
<li>setTimeout中时间延迟指定为0ms不会立即执行函数，会将其排队，等待前面的事件处理程序执行完后立即执行！！！<br>例子：<pre>/&lowast;<br>&lowast;函数f()的调用模式<br>&lowast;start毫秒后调用f()函数<br>&lowast;若设置了interval没有设置end函数会无限循环调用<br>&lowast;若设置了interval和end函数会在interval时间内重复调用<br>&lowast;若没有设置interval和end函数会只调用一次<br>&lowast;start缺省值为0ms<br>&lowast;/<br>function invoke(f,start,interval,end){<br>if(!start){start=0;}<br>if(arguments.length&lt;3){setTimeout(f,start);}<br>else{<pre><code>  setTimeout(repeat,start);
  function repeat(){
    var h=setInterval(f,interval);
    if(end){setTimeout(function (){clearInterval(h);},end);}
}
</code></pre>}<br>}<br></pre><h3 id="window对象的location属性-引用location对象-：表示该窗口中当前显示的文档的URL"><a href="#window对象的location属性-引用location对象-：表示该窗口中当前显示的文档的URL" class="headerlink" title="window对象的location属性(引用location对象)：表示该窗口中当前显示的文档的URL"></a>window对象的location属性(引用location对象)：表示该窗口中当前显示的文档的URL</h3></li>
</ul>
</li>
<li>location对象的href属性是一个字符串，值为当前文档的url(可以通过改变location.href实现页面跳转)；location对象的toString()方法会返回href属性的值（隐式调用toString()方法时可用location代替location.href）</li>
<li>location的其他属性，代表url的各个部分，均返回字符串（包括protocol,host,hostname,port,pathname,search等）<br>其中search属性返回问号之后的url，一般代表查询字段（可通过结合substring(start,end)方法取得参数，此处要用decodeURIComponent对其进行解码）</li>
<li>location对象的方法：<ul>
<li><code>location.assign（&quot;url&quot;）</code>:窗口载入并显示url</li>
<li><code>location.replace（&quot;url&quot;）</code>:窗口载入并显示url,载入前会从历史记录中删除当前文档，使后退操作无法回到当前</li>
<li><code>location.reload（）</code>:无参数，重新载入当前页面</li>
</ul>
</li>
<li>Tips:不存在锚点#top，location.href=’#top’也可回到顶部（<a>标签中同理）<h3 id="window对象的history属性-引用history对象-：表示当前窗口的历史记录"><a href="#window对象的history属性-引用history对象-：表示当前窗口的历史记录" class="headerlink" title="window对象的history属性(引用history对象)：表示当前窗口的历史记录"></a>window对象的history属性(引用history对象)：表示当前窗口的历史记录</h3></a></li>
<li>history.length:浏览历史列表中的元素数量</li>
<li>history对象的方法：<ul>
<li><code>history.back()</code>:无参数，回退一次</li>
<li><code>history.forward()</code>:无参数，前进一次</li>
<li><code>history.go(times)</code>:参数可正可负，正代表前进times次，负代表后退times次</li>
</ul>
</li>
<li>Tips:若窗口中包含&lt;iframe&gt;，其中的记录会穿插在历史记录中，后退前进操作可能会导致子窗口生效，主窗口无效<h3 id="window对象的navigator属性-引用navigator对象-：表示浏览器信息"><a href="#window对象的navigator属性-引用navigator对象-：表示浏览器信息" class="headerlink" title="window对象的navigator属性(引用navigator对象)：表示浏览器信息"></a>window对象的navigator属性(引用navigator对象)：表示浏览器信息</h3>这里navigator的名字是为纪念Netscape navigator浏览器</li>
<li>navigator的属性:<ul>
<li>navigator.appName:除IE不同，其他均为Netscape</li>
<li>navigator.appVersion:版本信息</li>
<li>navigator.userAgent:http头部发送的user-agent字符串</li>
<li>navigator.platform:浏览器的操作系统</li>
<li>其他属性还有onLine,geolocation,cookieEnable等等<h3 id="window对象的screen属性-引用screen对象-：表示屏幕信息，大小、颜色数量等"><a href="#window对象的screen属性-引用screen对象-：表示屏幕信息，大小、颜色数量等" class="headerlink" title="window对象的screen属性(引用screen对象)：表示屏幕信息，大小、颜色数量等"></a>window对象的screen属性(引用screen对象)：表示屏幕信息，大小、颜色数量等</h3></li>
</ul>
</li>
<li>screen.width/screen.height:像素为单位的窗口大小</li>
<li>screen.availWidth/screen.availHeight:实际可用的窗口大小</li>
<li>colorDepth:显示的BPP值（16,24,32…）<h3 id="对话框（会阻塞当前代码，用户体验不好）"><a href="#对话框（会阻塞当前代码，用户体验不好）" class="headerlink" title="对话框（会阻塞当前代码，用户体验不好）"></a>对话框（会阻塞当前代码，用户体验不好）</h3></li>
<li><code>alert(&#39;information&#39;)</code>:提示消息</li>
<li><code>confirm(&#39;information&#39;)</code>:确认信息，返回布尔值</li>
<li><code>prompt(&#39;information&#39;)</code>:用户输入框</li>
<li><code>showModalDialog(&#39;url&#39;,包含标题的内容（数组/对象），style内容如：&quot;dialogWidth;resizable=yes;&quot;等)</code>:模拟对话框<h3 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h3></li>
<li>一般通过try/catch捕获抛出错误，过去采用window.onerror事件<h3 id="HTML元素中使用值为非保留值的id属性时，其值会成为可以被脚本访问的全局变量（name属性不会这样；且name属性可重复，id属性必须唯一）"><a href="#HTML元素中使用值为非保留值的id属性时，其值会成为可以被脚本访问的全局变量（name属性不会这样；且name属性可重复，id属性必须唯一）" class="headerlink" title="HTML元素中使用值为非保留值的id属性时，其值会成为可以被脚本访问的全局变量（name属性不会这样；且name属性可重复，id属性必须唯一）"></a>HTML元素中使用值为非保留值的id属性时，其值会成为可以被脚本访问的全局变量（name属性不会这样；且name属性可重复，id属性必须唯一）</h3><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3></li>
<li>一个web窗口包含多个标签页，每个标签页都是独立的浏览上下文，每个上下文都有独立的window对象，相互之间互不干扰</li>
<li>打开：<code>window.open(&#39;url&#39;~~,name,style,bool~~)</code>:省略url会打开空白页；name已存在会指向该页面，不存在会以此命名新窗口；bool在name为已存在生效，是否替换当前历史记录，默认false</li>
<li>关闭：<code>window.close()</code>:显示指定window,避免与document.close()混淆</li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-26T14:13:26.000Z"><a href="/2016/05/26/黑魔法——纯css画一个三角形/">2016-05-26</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/26/黑魔法——纯css画一个三角形/">黑魔法——纯css画一个三角形</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="今天看《CSS设计指南（第3版）》的时候发现了一个神奇黑魔法，居然可以用纯css画出一个三角形，感觉好神奇！"><a href="#今天看《CSS设计指南（第3版）》的时候发现了一个神奇黑魔法，居然可以用纯css画出一个三角形，感觉好神奇！" class="headerlink" title="今天看《CSS设计指南（第3版）》的时候发现了一个神奇黑魔法，居然可以用纯css画出一个三角形，感觉好神奇！"></a>今天看《CSS设计指南（第3版）》的时候发现了一个神奇黑魔法，居然可以用纯css画出一个三角形，感觉好神奇！</h3><h3 id="原理是令盒模型宽高都为0，再通过border边框把三个边置为透明，只留一个有色边框即为所需三角形，如图所示。可在需要添加三角形的地方以-after或-before伪元素添加，这个例子就是这样。"><a href="#原理是令盒模型宽高都为0，再通过border边框把三个边置为透明，只留一个有色边框即为所需三角形，如图所示。可在需要添加三角形的地方以-after或-before伪元素添加，这个例子就是这样。" class="headerlink" title="原理是令盒模型宽高都为0，再通过border边框把三个边置为透明，只留一个有色边框即为所需三角形，如图所示。可在需要添加三角形的地方以::after或::before伪元素添加，这个例子就是这样。"></a>原理是令盒模型宽高都为0，再通过border边框把三个边置为透明，只留一个有色边框即为所需三角形，如图所示。可在需要添加三角形的地方以<code>::after</code>或<code>::before</code>伪元素添加，这个例子就是这样。</h3><p><img src="http://o6yo3ducz.bkt.clouddn.com/triangleTheory.png" alt="三角形的原理图"></p>
<p><pre style="font-size:20px;">CSS代码<br>.triangle:after {<br>            content: “”;        //content为必填属性<br>            border: 12px solid;<br>            //通过border边框把三个边置为透明，只留一个有色边框即为所需三角形，这里是红色三角形<br>            border-color: transparent red transparent transparent;<br>            height: 0;         //高必须为0<br>            width: 0;          //宽必须为0<br>            display: block;    //必须以block方式显示<br>        }<br></pre></p>
<h3 id="HTML部分只需-lt-div-class-”triangle”-gt-lt-div-gt-即可显示一个三角形"><a href="#HTML部分只需-lt-div-class-”triangle”-gt-lt-div-gt-即可显示一个三角形" class="headerlink" title="HTML部分只需&lt;div class=”triangle”&gt;&lt;/div&gt;即可显示一个三角形~~~"></a>HTML部分只需&lt;div class=”triangle”&gt;&lt;/div&gt;即可显示一个三角形~~~</h3>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/css/">css</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/纯css画三角形/">纯css画三角形</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-26T14:07:20.000Z"><a href="/2016/05/26/《javascript权威指南》学习笔记（5）/">2016-05-26</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/26/《javascript权威指南》学习笔记（5）/">《javascript权威指南》学习笔记（5）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="第13章-客户端Javascript"><a href="#第13章-客户端Javascript" class="headerlink" title="第13章 客户端Javascript"></a>第13章 客户端Javascript</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<h3 id="DHTML-动态的HTML"><a href="#DHTML-动态的HTML" class="headerlink" title="DHTML:动态的HTML"></a>DHTML:动态的HTML</h3><h3 id="在HTML中嵌入JS"><a href="#在HTML中嵌入JS" class="headerlink" title="在HTML中嵌入JS"></a>在HTML中嵌入JS</h3><p>1.内联：&lt;script&gt;&lt;/script&gt;之间加入JS代码<br>2.外部文件：&lt;script&gt;的src属性指定js文件路径<br>3.HTML的事件处理程序属性指定（如：onclick属性等）<br>4.在url中使用”javascript:”协议，如<code>&lt;a href=&quot;javascript:&quot;&gt;</code>（ <code>javascript:void(0)</code>防止页面跳转时到顶部，师傅说兼容性不好，直接<code>javascript:</code>比较好）</p>
<ul>
<li>Tips：<ul>
<li>&lt;script&gt;标签的type属性默认为text/javascript，无特殊不需额外指定</li>
<li>使用HTML的事件处理程序属性不是一个好习惯，要保持内容(html)和行为(js)分离(css为表现)<h3 id="延迟JS执行"><a href="#延迟JS执行" class="headerlink" title="延迟JS执行"></a>延迟JS执行</h3>&lt;script&gt;有<code>defer</code>和<code>async</code>属性，它们是布尔属性，没有值</li>
</ul>
</li>
<li><code>defer</code>(延迟):延迟脚本执行，直到文档载入和解析完成，并可以操作（会按序执行）</li>
<li><code>async</code>(异步):在下载脚本时不阻塞文档解析，脚本下载完成后尽快执行，也就是说下载脚本和解析文档同时进行（可能不会按序执行）<br>Tips：</li>
<li>当两个属性同时存在，会忽略<code>defer</code>遵从<code>async</code></li>
<li>这两个属性存在时，禁止使用<code>document.write()</code><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3>程序响应一个事件需要写一个函数，再注册这个函数，这样会在事件发生时调用它。注册可以直接通过HTML中的HTML的事件处理程序属性完成（不是个好习惯），一般在js文件中进行注册</li>
<li>写事件处理程序时不需调用这个函数，在事件发生时会自动调用</li>
<li>事件处理程序属性以on开始，后跟事件的名字（click,change,load,keypress等等）</li>
<li><code>addEventListener()</code>在IE9+才支持，<code>attachEvent()</code>在IE8中使用。这时候使用jquery等框架兼容性会更好<h3 id="JS的线程机制"><a href="#JS的线程机制" class="headerlink" title="JS的线程机制"></a>JS的线程机制</h3>JS没有定义任何线程机制，按单线程工作。但HTML5支持WebWorker并发控制方式，模拟多线程，可以用来执行复杂的计算任务而不冻结界面<h3 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h3>本域内的脚本仅有权限访问本域内的资源（同IP，同协议，同端口视为一个域）<h3 id="XSS（跨站脚本）攻击"><a href="#XSS（跨站脚本）攻击" class="headerlink" title="XSS（跨站脚本）攻击"></a>XSS（跨站脚本）攻击</h3>攻击者向目标Web站点注入HTML标签或脚本<br>eg：<a href="http://xxx.xxx.xxx?" target="_blank" rel="external">http://xxx.xxx.xxx?</a><span style="color:red">%3Cscript%3Ealert(‘evil’)%3C/script%3</span>,红色部分为攻击者注入<br>防范：使用任何不可信数据动态创建文档前，从中移除html标签<h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3>使用如<code>alert()</code>对话框等无意义内容无限循环占用浏览器，使得浏览器无法正常工作<br>但由于没有人会返回滥用这种脚本的网站，这种攻击不常见</li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-18T08:33:43.000Z"><a href="/2016/05/18/《javascript权威指南》学习笔记（4）/">2016-05-18</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/18/《javascript权威指南》学习笔记（4）/">《javascript权威指南》学习笔记（4）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="函数篇"><a href="#函数篇" class="headerlink" title="函数篇"></a>函数篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义<p style="font-size:20px;"></p></h3><ul>
<li>声明：function name(){…}</li>
<li>表达式：var fun=function name(){…},在函数表达式中，函数名称标识name对命名表达式是可选项，如果存在名称标识name只在函数体中生效（函数定义表达式适合用来定义只用到一次的函数）</li>
<li>区别：函数声明会被提前到外部脚本或外部函数作用域顶部，可以在定义前调用。而函数表达式的var声明部分不会提前，所以函数表达式不可以在声明前调用。</li>
<li>tips:<br>1.函数作为对象私有函数时，对应属性名以下划线做前缀，表明私有！<br>2.函数声明语句非真正的语句，不能出现在循环、条件判断、try/catch、with等语句中；但函数表达式可以出现在任何地方<p></p><h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数<p style="font-size:20px;"></p></h3></li>
<li>变量作用域：内部函数可以访问外部函数变量，但外部函数不可以访问内部函数的变量<p></p><h3 id="对象属性中的函数"><a href="#对象属性中的函数" class="headerlink" title="对象属性中的函数"></a>对象属性中的函数<p style="font-size:20px;"></p></h3></li>
<li>在方法中使用对象的属性对应的值，要用this.prop指向当前对象的属性，否则会寻找全局变量。<br>eg:<code>var calculator={op1:1,op2:2,add:function (){this.result=this.op1+this.op2;}}</code></li>
<li>希望this指向外部对象时要先用that把this保存起来，不能直接用this<p></p><h3 id="不定实参函数（不定实参函数要加备注！）"><a href="#不定实参函数（不定实参函数要加备注！）" class="headerlink" title="不定实参函数（不定实参函数要加备注！）"></a>不定实参函数（不定实参函数要加备注！）<p style="font-size:20px;"></p></h3></li>
<li>arguments为一个类数组，arguments在严格模式下为保留字，非严格模式下非保留字</li>
<li>对不定参数个数的函数可用arguments.length访问参数长度，arguments[i]访问第i+1个参数</li>
<li>arguments的其他属性（非严格模式可用）：<br>1.callee:返回当前正在执行的函数体（匿名函数通过这种方式递归调用自身）<br>2.caller：返回调用栈<p></p><h3 id="函数还可以作为参数值传入另一函数（如sort（）参数可传入函数）"><a href="#函数还可以作为参数值传入另一函数（如sort（）参数可传入函数）" class="headerlink" title="函数还可以作为参数值传入另一函数（如sort（）参数可传入函数）"></a>函数还可以作为参数值传入另一函数（如sort（）参数可传入函数）</h3><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域<p style="font-size:20px;"></p></h3></li>
<li>函数中声明的变量在整个函数体内可见，在函数外部是不可见的，内部函数可以访问外部函数变量，但外部函数不可以访问内部函数的变量</li>
<li>立即执行的匿名函数不会污染全局的命名空间</li>
<li>tips：<code>（function (){…}）();</code>其中第一对括号JS解释器会将其解释为函数表达式<p></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包<p style="font-size:20px;"></p></h3></li>
<li>函数体内部的变量可以保存在函数作用域内</li>
<li>当函数嵌套了另一函数，以内部函数对象为返回值时，闭包所指向的作用域链与定义函数时的作用域链不是同一作用域链，所以局部变量不会被垃圾回收机制回收，一直存在于内存中<br>eg:getter,setter方法：<code>function counter(n){return {get count(){return n++;},set count(m){if(m&gt;n) n=m;else throw Error(&quot;必须大于n&quot;);}}}</code><br><pre>var c=counter(1000);<br> c.count;            //1000<span style="color:red">不可用c.count(),无function声明不可用方法方式调用</span><br> c.count;            //1001<br> c.count=2000;<br> c.count;            //2000</pre><p></p><h3 id="函数的bind方法"><a href="#函数的bind方法" class="headerlink" title="函数的bind方法"></a>函数的bind方法</h3><h3 id="fun-bind-o-para-将函数作为对象o的私有方法绑定给指定对象o，返回新方法。第二个参数为function的首个参数，可省略"><a href="#fun-bind-o-para-将函数作为对象o的私有方法绑定给指定对象o，返回新方法。第二个参数为function的首个参数，可省略" class="headerlink" title="fun.bind(o,~~para~~)将函数作为对象o的私有方法绑定给指定对象o，返回新方法。第二个参数为function的首个参数，可省略"></a><code>fun.bind(o,~~para~~)</code><span style="font-size:20px">将函数作为对象o的私有方法绑定给指定对象o，返回新方法。第二个参数为function的首个参数，可省略</span></h3><pre style="font-size:20px;">eg:function f(y){return this.x+y;}<br>var o={x:1};<br>g=f.bind(o);<br>g(2);         //3</pre><div style="font-size:20px;"></div></li>
<li>Function()构造函数会创建匿名函数，return Function()构造器创建的函数this会返回全局<h3 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数<div style="font-size:20px;"></div></h3>高阶函数、操作函数的函数（接受函数作参数返回新函数）、不完全函数（完整函数拆分为多部分函数调用）目前对我来说太高深了!!!见书197,198页</li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-17T14:57:36.000Z"><a href="/2016/05/17/用纯css实现多级导航菜单/">2016-05-17</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/17/用纯css实现多级导航菜单/">用纯css实现多级导航菜单</a></h1>
  

    </header>
    <div class="entry">
      
        <p><img src="http://o6yo3ducz.bkt.clouddn.com/%E7%BA%AFcss%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%A7%E5%AF%BC%E8%88%AA.gif" title="纯css实现多级导航"></p>
<h3 id="css代码部分："><a href="#css代码部分：" class="headerlink" title="css代码部分："></a>css代码部分：</h3><p><pre style="font-size:20px;"><br>html,body,div,ul,li,a{margin:0;padding: 0;text-decoration: none;}<br>        .nav{<br>            font-size: 28px;<br>            color: mediumpurple;<br>            text-align: center;<br>        }<br>        .nav li{<br>           float:left;<br>           list-style: none;<br>           /<em>relative为后续下级菜单absolute定义提供基位置</em>/<br>           position: relative;<br>           width:250px;}<br>        .nav a:hover{<br>            background-color: mediumpurple;<br>            color: white;<br>        }<br>        .firstMenu li a,.secondMenu li a,.thirdMenu li a{<br>            display: block;<br>            background: yellowgreen;<br>            border:2px solid transparent;<br>            padding: 5px 9px;<br>            background-clip: padding-box;<br>        }<br>        .thirdMenu,.secondMenu{display: none;}<br>        .secondMenu{<br>            position: absolute;<br>            top:100%;/<em>顶边与一级菜单底边对齐</em>/<br>            left:0;<br>        }<br>        .thirdMenu{<br>            position: absolute;<br>            left: 100%;/<em>左边与二级菜单右边对齐</em>/<br>            top:0;<br>        }<br>        .secondMenu li,.thirdMenu li{<br>            float: none;<br>        }<br>        /<em>控制下拉菜单悬停显示</em>/<br>        .firstMenu li:hover &gt; ul{<br>            display: block;<br>        }<br>        /<em>记录选中的菜单栏</em>/<br>        .nav li:hover&gt;a{<br>            background-color: mediumpurple;<br>            color: white;<br>        }<br></pre></p>
<h3 id="html代码部分："><a href="#html代码部分：" class="headerlink" title="html代码部分："></a>html代码部分：</h3><p><pre style="font-size:20px;">&lt;div class=”nav”&gt;<br>    &lt;ul class=”firstMenu”&gt;<br>        &lt;!–一级开始–&gt;<br>        &lt;li&gt;&lt;a href=”#”&gt;power&lt;/a&gt;&lt;/li&gt;<br>        &lt;li&gt;&lt;a href=”#”&gt;money&lt;/a&gt;&lt;/li&gt;<br>        &lt;li&gt;&lt;a href=”#”&gt;love&lt;/a&gt;<br>            &lt;!–二级开始–&gt;<br>            &lt;ul class=”secondMenu”&gt;<br>                &lt;li&gt;&lt;a href=”#”&gt;sports star&lt;/a&gt;&lt;/li&gt;<br>                &lt;li&gt;&lt;a href=”#”&gt;movie star&lt;/a&gt;&lt;/li&gt;<br>                &lt;li&gt;&lt;a href=”#”&gt;rock star&lt;/a&gt;<br>                    &lt;!–三级开始–&gt;<br>                    &lt;ul class=”thirdMenu”&gt;<br>                        &lt;li&gt;&lt;a href=”#”&gt;123&lt;/a&gt;&lt;/li&gt;<br>                        &lt;li&gt;&lt;a href=”#”&gt;abc&lt;/a&gt;&lt;/li&gt;<br>                        &lt;li&gt;&lt;a href=”#”&gt;def&lt;/a&gt;&lt;/l&gt;<br>                    &lt;/ul&gt;<br>                    &lt;!–三级结束–&gt;<br>                &lt;/li&gt;<br>            &lt;/ul&gt;<br>            &lt;!–二级结束–&gt;<br>        &lt;/li&gt;<br>        &lt;li&gt;&lt;a href=”#”&gt;fame&lt;/a&gt;<br>            &lt;!–二级开始–&gt;<br>            &lt;ul class=”secondMenu”&gt;<br>                &lt;li&gt;&lt;a href=”#”&gt;sports star&lt;/a&gt;&lt;/li&gt;<br>                &lt;li&gt;&lt;a href=”#”&gt;movie star&lt;/a&gt;&lt;/li&gt;<br>                &lt;li&gt;&lt;a href=”#”&gt;rock star&lt;/a&gt;<br>                    &lt;!–三级开始–&gt;<br>                    &lt;ul class=”thirdMenu”&gt;<br>                        &lt;li&gt;&lt;a href=”#”&gt;123&lt;/a&gt;&lt;/li&gt;<br>                        &lt;li&gt;&lt;a href=”#”&gt;abc&lt;/a&gt;&lt;/li&gt;<br>                        &lt;li&gt;&lt;a href=”#”&gt;def&lt;/a&gt;&lt;/li&gt;<br>                    &lt;/ul&gt;<br>                    &lt;!–三级结束–&gt;<br>                &lt;/li&gt;<br>            &lt;/ul&gt;<br>            &lt;!–二级结束–&gt;<br>        &lt;/li&gt;<br>        &lt;!–一级结束–&gt;<br>    &lt;/ul&gt;<br>    &lt;/div&gt;<br></pre></p>
<h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：<div style="font-size:18px;"></div></h3><p>1.&lt;li&gt;标签下的&lt;a&gt;标签设为display:block可以使文字部分及整个周围空白都可以点击，可点击范围不止局限于文字<br>2.background-clip：padding-box使背景色范围只到padding，通过把边框置为透明可以显示后层的背景<br>3.注释中内容的很重要<br>4.基本思想是鼠标悬停时显示下级菜单，否则隐藏。再结合position:absolute通过从当前父级&lt;li&gt;开始定位（父级position要设为relative）控制下级菜单的显示位置<br></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/css/">css</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/纯css实现多级nav/">纯css实现多级nav</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-13T14:17:31.000Z"><a href="/2016/05/13/闭包和作用域的小例子/">2016-05-13</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/13/闭包和作用域的小例子/">闭包和作用域的小例子</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="this指向当前对象，在函数闭包返回变量时不需要this直接返回！今天我傻傻的还在下面的程序里写了this-a……噗……"><a href="#this指向当前对象，在函数闭包返回变量时不需要this直接返回！今天我傻傻的还在下面的程序里写了this-a……噗……" class="headerlink" title="this指向当前对象，在函数闭包返回变量时不需要this直接返回！今天我傻傻的还在下面的程序里写了this.a……噗……"></a>this指向当前对象，在函数闭包返回变量时不需要this直接返回！今天我傻傻的还在下面的程序里写了this.a……噗……</h3><p><pre style="font-size:20px;">eg：<br>function test(){<br>    var a=3;<br>    return{                //这里返回一个对象<br>        get:function (){<br>            return a;<br>        },<br>        set:function (a1){<br>            a=a1;<br>        }<br>    }<br>}<br>a;               //a为私有变量，访问不到，全局a为undefined，故返回undefined<br>test().get();    //返回a的值3<br>test().set(4);<br>test().get();    //<span style="color:red;">返回3，这是因为每次test()都会重新初始化重新将a置为初始值3，执行上文没有被保存</span><br>var obj=test();<br>obj.set(4);<br>obj.get();       //<span style="color:red;">返回4，var obj=test()会使得执行上文每次都会保存，不会重新初始化</span></pre></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr>
<h3 id="师傅今天考了我一道作用域的题，没答对。。。书白看了。。。"><a href="#师傅今天考了我一道作用域的题，没答对。。。书白看了。。。" class="headerlink" title="师傅今天考了我一道作用域的题，没答对。。。书白看了。。。"></a>师傅今天考了我一道作用域的题，没答对。。。书白看了。。。</h3><p><pre style="font-size:20px">var name=1;<br>var obj={<br>name:2,<br>b:{<br>  name:3,<br>  c:{<br>    name:4,<br>    getName:function (){<br>            console.log(this.name);  //这里最开始为return this.name，这样的话setTimeout(obj.b.c.getName,1000)<br>                                     //会返回其唯一的标识时延的id，没有返回全局下name<br>            }<br>    }<br>  }<br>}<br></pre></p>
<p><pre style="font-size:20px"><br>obj.b.c.getName();                  //4<br>var a1=obj.b;<br>a1.c.getName();                     //4<br>var b1=obj.b.c;<br>b1.getName();                       //4<br>setTimeout(obj.b.c.getName,1000);   //1<br>setTimeout(obj.b.c.getName(),1000); //4<br>var cGet=obj.b.c.getName;<br>cGet();                             //1<br></pre></p>
<h4 id="obj-b-c-getName-，a1-c-getName-，b1-getName-调用getName-时this均指向当前对象，即最内层c对象，故返回c-name。"><a href="#obj-b-c-getName-，a1-c-getName-，b1-getName-调用getName-时this均指向当前对象，即最内层c对象，故返回c-name。" class="headerlink" title="obj.b.c.getName()，a1.c.getName()，b1.getName()调用getName()时this均指向当前对象，即最内层c对象，故返回c.name。"></a><code>obj.b.c.getName()</code>，<code>a1.c.getName()</code>，<code>b1.getName()</code>调用getName()时<code>this</code>均指向当前对象，即最内层c对象，故返回<code>c.name</code>。</h4><h4 id="setTimeout-obj-b-c-getName-1000-生效时，this指向window对象，相当于创建临时变量并把obj-b-c-getName赋给这个临时变量，注意这里没有-表示调用，临时变量中内容为function-console-log-this-name-，this指向全局，故返回全局下name，即window-name。"><a href="#setTimeout-obj-b-c-getName-1000-生效时，this指向window对象，相当于创建临时变量并把obj-b-c-getName赋给这个临时变量，注意这里没有-表示调用，临时变量中内容为function-console-log-this-name-，this指向全局，故返回全局下name，即window-name。" class="headerlink" title="setTimeout(obj.b.c.getName,1000)生效时，this指向window对象，相当于创建临时变量并把obj.b.c.getName赋给这个临时变量，注意这里没有()表示调用，临时变量中内容为function (){console.log(this.name);}，this指向全局，故返回全局下name，即window.name。"></a><code>setTimeout(obj.b.c.getName,1000)</code>生效时，<code>this</code>指向<code>window</code>对象，相当于创建临时变量并把<code>obj.b.c.getName</code>赋给这个临时变量，注意这里没有()表示调用，临时变量中内容为<code>function (){console.log(this.name);}</code>，<code>this</code>指向全局，故返回全局下name，即<code>window.name</code>。</h4><h4 id="setTimeout-obj-b-c-getName-1000-生效时相当于直接从obj-b-c下调用c的getName-方法，此时this在其中指向c。"><a href="#setTimeout-obj-b-c-getName-1000-生效时相当于直接从obj-b-c下调用c的getName-方法，此时this在其中指向c。" class="headerlink" title="setTimeout(obj.b.c.getName(),1000)生效时相当于直接从obj.b.c下调用c的getName()方法，此时this在其中指向c。"></a><code>setTimeout(obj.b.c.getName(),1000)</code>生效时相当于直接从<code>obj.b.c</code>下调用c的getName()方法，此时<code>this</code>在其中指向c。</h4><h4 id="cGet同样相当于把obj-b-c-getName下的function赋值给cGet变量，调用时this同样指向全局name。相当于把getName私有方法抓取出来到全局了。"><a href="#cGet同样相当于把obj-b-c-getName下的function赋值给cGet变量，调用时this同样指向全局name。相当于把getName私有方法抓取出来到全局了。" class="headerlink" title="cGet同样相当于把obj.b.c.getName下的function赋值给cGet变量，调用时this同样指向全局name。相当于把getName私有方法抓取出来到全局了。"></a>cGet同样相当于把<code>obj.b.c.getName</code>下的function赋值给cGet变量，调用时this同样指向全局name。相当于把getName私有方法抓取出来到全局了。</h4>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>, <a href="/categories/technology/javascript/日常的问题/">日常的问题</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/闭包和作用域/">闭包和作用域</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-13T12:39:55.000Z"><a href="/2016/05/13/《javascript权威指南》学习笔记（3）/">2016-05-13</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/13/《javascript权威指南》学习笔记（3）/">《javascript权威指南》学习笔记（3）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="对象篇"><a href="#对象篇" class="headerlink" title="对象篇"></a>对象篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<h4 id="属性名中有空格、连字符、保留字时，要用引号以字符串形式表示。"><a href="#属性名中有空格、连字符、保留字时，要用引号以字符串形式表示。" class="headerlink" title="属性名中有空格、连字符、保留字时，要用引号以字符串形式表示。"></a>属性名中有<strong>空格、连字符、保留字</strong>时，要用引号以字符串形式表示。</h4><hr>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="直接量：var-obj-…"><a href="#直接量：var-obj-…" class="headerlink" title="直接量：var obj={…}"></a>直接量：var obj={…}</h4><h4 id="关键字：new-构造函数。var-obj-new-Object-Array-Date"><a href="#关键字：new-构造函数。var-obj-new-Object-Array-Date" class="headerlink" title="关键字：new+构造函数。var obj=new Object()/Array()/Date()"></a>关键字：new+构造函数。var obj=new Object()/Array()/Date()</h4><h4 id="Object-create-原型对象-var-obj-inherit-原型对象-。（二者有一些区别，如inherit不能继承自空对象等）"><a href="#Object-create-原型对象-var-obj-inherit-原型对象-。（二者有一些区别，如inherit不能继承自空对象等）" class="headerlink" title="Object.create(原型对象)/var obj=inherit(原型对象)。（二者有一些区别，如inherit不能继承自空对象等）"></a>Object.create(原型对象)/var obj=inherit(原型对象)。（二者有一些区别，如inherit不能继承自空对象等）</h4><hr>
<h3 id="查询：在查询时可能会查询原型链，设置时则不会更改原型链-setter方法设置不改变原型链"><a href="#查询：在查询时可能会查询原型链，设置时则不会更改原型链-setter方法设置不改变原型链" class="headerlink" title="查询：在查询时可能会查询原型链，设置时则不会更改原型链(setter方法设置不改变原型链)"></a>查询：在查询时可能会查询原型链，设置时则不会更改原型链(setter方法设置不改变原型链)</h3><h4 id="1-object-property-2-object-property-若属性名含引号-内也要含！"><a href="#1-object-property-2-object-property-若属性名含引号-内也要含！" class="headerlink" title="1.object.property;2.object[property](若属性名含引号[]内也要含！)"></a>1.<code>object.property</code>;2.<code>object[property]</code>(若属性名含引号[]内也要含！)</h4><h4 id="方式比-方式更强大一些："><a href="#方式比-方式更强大一些：" class="headerlink" title="[]方式比.方式更强大一些："></a>[]方式比.方式更强大一些：</h4><h4 id="方式可以访问保留字为名的属性，可以在运行时动态更改其内的属性名；"><a href="#方式可以访问保留字为名的属性，可以在运行时动态更改其内的属性名；" class="headerlink" title="[]方式可以访问保留字为名的属性，可以在运行时动态更改其内的属性名；"></a>[]方式可以访问保留字为名的属性，可以在运行时动态更改其内的属性名；</h4><h4 id="方式不可以访问保留字为名的属性，运行时不可以动态更改属性名只能做为索引。"><a href="#方式不可以访问保留字为名的属性，运行时不可以动态更改属性名只能做为索引。" class="headerlink" title=".方式不可以访问保留字为名的属性，运行时不可以动态更改属性名只能做为索引。"></a>.方式不可以访问保留字为名的属性，运行时不可以动态更改属性名只能做为索引。</h4><hr>
<h3 id="删除属性：delete-obj-property，删除成功或无副作用（删除不存在的属性时）返回true"><a href="#删除属性：delete-obj-property，删除成功或无副作用（删除不存在的属性时）返回true" class="headerlink" title="删除属性：delete obj.property，删除成功或无副作用（删除不存在的属性时）返回true"></a>删除属性：<code>delete obj.property</code>，删除成功或无副作用（删除不存在的属性时）返回true</h3><hr>
<h3 id="属性检测"><a href="#属性检测" class="headerlink" title="属性检测"></a>属性检测</h3><h4 id="hasOwnProperty-是否为对象自有属性（不属于继承属性）"><a href="#hasOwnProperty-是否为对象自有属性（不属于继承属性）" class="headerlink" title="- hasOwnProperty():是否为对象自有属性（不属于继承属性）"></a>- hasOwnProperty():是否为对象自有属性（不属于继承属性）</h4><h4 id="propertyIsEnumerable-是否为对象自有属性且可枚举"><a href="#propertyIsEnumerable-是否为对象自有属性且可枚举" class="headerlink" title="- propertyIsEnumerable():是否为对象自有属性且可枚举"></a>- propertyIsEnumerable():是否为<strong>对象自有属性</strong>且<strong>可枚举</strong></h4><h4 id="判断属性是否undefined-严格不等于可区分null和undefined"><a href="#判断属性是否undefined-严格不等于可区分null和undefined" class="headerlink" title="- !==:判断属性是否undefined(严格不等于可区分null和undefined)"></a>- !==:判断属性是否undefined(严格不等于可区分null和undefined)</h4><h4 id="property-in-object-区分存在但值为undefined还是不存在"><a href="#property-in-object-区分存在但值为undefined还是不存在" class="headerlink" title="- property in object:区分存在但值为undefined还是不存在"></a>- property in object:区分存在但值为undefined还是不存在</h4><h4 id="keys-返回所有对象自有的可枚举属性名组成的数组"><a href="#keys-返回所有对象自有的可枚举属性名组成的数组" class="headerlink" title="- keys():返回所有对象自有的可枚举属性名组成的数组"></a>- keys():返回所有对象自有的可枚举属性名组成的数组</h4><h4 id="getOwnPropertyNames-返回所有对象自有的属性名组成的数组（包括不可枚举的）"><a href="#getOwnPropertyNames-返回所有对象自有的属性名组成的数组（包括不可枚举的）" class="headerlink" title="- getOwnPropertyNames():返回所有对象自有的属性名组成的数组（包括不可枚举的）"></a>- getOwnPropertyNames():返回所有对象自有的属性名组成的数组（包括不可枚举的）</h4><h4 id="for-in循环会遍历原型链上的可枚举属性，可通过if-obj-hasOwnProperty-prop-过滤"><a href="#for-in循环会遍历原型链上的可枚举属性，可通过if-obj-hasOwnProperty-prop-过滤" class="headerlink" title="for in循环会遍历原型链上的可枚举属性，可通过if(obj.hasOwnProperty(prop))过滤"></a><strong>for in循环会遍历原型链上的可枚举属性，可通过<code>if(obj.hasOwnProperty(prop))</code>过滤</strong></h4><hr>
<h3 id="getter与setter属性：查询及设置属性，不需function关键字声明"><a href="#getter与setter属性：查询及设置属性，不需function关键字声明" class="headerlink" title="getter与setter属性：查询及设置属性，不需function关键字声明"></a>getter与setter属性：查询及设置属性，不需function关键字声明</h3><p><pre style="font-size:20px"><br>var obj={<br>    x:1,<br>    get propX(){<br>        return this.x;<br>    },<br>    set propX(x){        //setter只允许一个参数<br>        this.x=x;<br>    }<br>}<br></pre></p>
<h4 id="调用时：obj-propX-这样是getter-obj-propX-value-这样是setter-。采用obj-propX-会报错obj-propX不是function"><a href="#调用时：obj-propX-这样是getter-obj-propX-value-这样是setter-。采用obj-propX-会报错obj-propX不是function" class="headerlink" title="调用时：obj.propX(这样是getter),obj.propX=value(这样是setter)。采用obj.propX()会报错obj.propX不是function!"></a>调用时：<code>obj.propX</code>(这样是getter),<code>obj.propX=value</code>(这样是setter)。采用obj.propX()会报错obj.propX不是function!</h4><hr>
<h3 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h3><h3 id="数据对象属性：writable-configurable-enumerable-value"><a href="#数据对象属性：writable-configurable-enumerable-value" class="headerlink" title="-数据对象属性：writable,configurable,enumerable,value"></a>-数据对象属性：writable,configurable,enumerable,value</h3><h3 id="存取器对象属性：set-configurable-enumerable-get"><a href="#存取器对象属性：set-configurable-enumerable-get" class="headerlink" title="-存取器对象属性：set,configurable,enumerable,get"></a>-存取器对象属性：set,configurable,enumerable,get</h3><h4 id="采用defineProperty-对象-quot-属性-quot-特性-方式定义需定义特性的属性，特性可省略，默认值value为undefined，其他为false"><a href="#采用defineProperty-对象-quot-属性-quot-特性-方式定义需定义特性的属性，特性可省略，默认值value为undefined，其他为false" class="headerlink" title="采用defineProperty(对象,&quot;属性&quot;,~~{特性}~~)方式定义需定义特性的属性，特性可省略，默认值value为undefined，其他为false"></a>采用<code>defineProperty(对象,&quot;属性&quot;,~~{特性}~~)</code>方式定义需定义特性的属性，特性可省略，默认值value为undefined，其他为false</h4><h4 id="直接量定义的属性的特性除value外默认为true"><a href="#直接量定义的属性的特性除value外默认为true" class="headerlink" title="直接量定义的属性的特性除value外默认为true"></a>直接量定义的属性的特性除value外默认为true</h4><h4 id="多属性可用defineProperties-…"><a href="#多属性可用defineProperties-…" class="headerlink" title="多属性可用defineProperties(…)"></a>多属性可用defineProperties(…)</h4><h3 id="属性特性的查询："><a href="#属性特性的查询：" class="headerlink" title="属性特性的查询："></a>属性特性的查询：</h3><h4 id="Object-getOwnPropertyDescriptor-object-property-：返回object自有属性特性"><a href="#Object-getOwnPropertyDescriptor-object-property-：返回object自有属性特性" class="headerlink" title="-Object.getOwnPropertyDescriptor(object,property)：返回object自有属性特性"></a>-<code>Object.getOwnPropertyDescriptor(object,property)</code>：返回object自有属性特性</h4><hr>
<h3 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h3><h4 id="Object-getPrototypeOf-object-：遍历原型链的属性"><a href="#Object-getPrototypeOf-object-：遍历原型链的属性" class="headerlink" title="-Object.getPrototypeOf(object)：遍历原型链的属性"></a>-<code>Object.getPrototypeOf(object)</code>：遍历原型链的属性</h4><h4 id="object1-IsPrototypeOf-object2-：object1是否为object2的原型"><a href="#object1-IsPrototypeOf-object2-：object1是否为object2的原型" class="headerlink" title="-object1.IsPrototypeOf(object2)：object1是否为object2的原型"></a>-<code>object1.IsPrototypeOf(object2)</code>：object1是否为object2的原型</h4><hr>
<h3 id="可扩展性：要结合configurable和writable"><a href="#可扩展性：要结合configurable和writable" class="headerlink" title="可扩展性：要结合configurable和writable"></a>可扩展性：要结合configurable和writable</h3><h4 id="通过isExtensible-判断可扩展性"><a href="#通过isExtensible-判断可扩展性" class="headerlink" title="通过isExtensible()判断可扩展性"></a>通过isExtensible()判断可扩展性</h4><h4 id="阻止扩展preventExtensions-——这里转为不可扩展无法转回"><a href="#阻止扩展preventExtensions-——这里转为不可扩展无法转回" class="headerlink" title="阻止扩展preventExtensions()——这里转为不可扩展无法转回"></a>阻止扩展preventExtensions()——这里转为不可扩展无法转回</h4><h4 id="更严格锁定object-freeze"><a href="#更严格锁定object-freeze" class="headerlink" title="更严格锁定object.freeze()"></a>更严格锁定object.freeze()</h4><hr>
<h3 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h3><h4 id="JSON-stringify-obj-将js对象转为JSON对象-JSON-parse-obj-将JSON对象转为js对象"><a href="#JSON-stringify-obj-将js对象转为JSON对象-JSON-parse-obj-将JSON对象转为js对象" class="headerlink" title="-JSON.stringify(obj)将js对象转为JSON对象,JSON.parse(obj)将JSON对象转为js对象"></a>-JSON.stringify(obj)将js对象转为JSON对象,JSON.parse(obj)将JSON对象转为js对象</h4><hr>
<h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><h4 id="toString-返回对象值的字符串（对象返回-“object-Object”-数组转为字符串-函数转为函数源代码的字符串）"><a href="#toString-返回对象值的字符串（对象返回-“object-Object”-数组转为字符串-函数转为函数源代码的字符串）" class="headerlink" title="toString():返回对象值的字符串（对象返回[“object Object”],数组转为字符串,函数转为函数源代码的字符串）"></a>toString():返回对象值的字符串（对象返回[“object Object”],数组转为字符串,函数转为函数源代码的字符串）</h4><h4 id="toLocaleString-返回对象本地化字符串（一般与toString-相同，Date-和Number特殊）"><a href="#toLocaleString-返回对象本地化字符串（一般与toString-相同，Date-和Number特殊）" class="headerlink" title="toLocaleString():返回对象本地化字符串（一般与toString()相同，Date()和Number特殊）"></a>toLocaleString():返回对象本地化字符串（一般与toString()相同，Date()和Number特殊）</h4><h4 id="valueOf-对象转为原始值，尤其转换为数字时"><a href="#valueOf-对象转为原始值，尤其转换为数字时" class="headerlink" title="valueOf():对象转为原始值，尤其转换为数字时"></a>valueOf():对象转为原始值，尤其转换为数字时</h4>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  <div class="widget tag">
  <h3 class="title">关于 wo</h3>
  <ul class="entry">
    <li style="padding-left: 40px;"><img width="150px" src="http://o6yoa3nwp.bkt.clouddn.com/me.jpg" title="头像"/></li>
    <br/><hr/><br/>
    <li>丁丁</li>
    <li>双子座</li>
    <li>爱生活，爱技术，爱旅行，爱摄影</li><br/><hr/><br/>
    <li style="text-align: center;"><a target="_blank" href="http://weibo.com/u/2258194143?refer_flag=1001030102_&is_all=1">go to 我的微博</a></li>
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/technology/css/">css</a><small>2</small></li>
  
    <li><a href="/categories/technology/javascript/">javascript</a><small>9</small></li>
  
    <li><a href="/categories/plan/">plan</a><small>1</small></li>
  
    <li><a href="/categories/technology/">technology</a><small>11</small></li>
  
    <li><a href="/categories/technology/javascript/日常的问题/">日常的问题</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/06/14/《javascript权威指南》学习笔记（9）/"></a>
      </li>
    
      <li>
        <a href="/2016/06/14/《javascript权威指南》学习笔记（8）/">《javascript权威指南》学习笔记（8）</a>
      </li>
    
      <li>
        <a href="/2016/06/06/《javascript权威指南》学习笔记（7）/">《javascript权威指南》学习笔记（7）</a>
      </li>
    
      <li>
        <a href="/2016/06/06/《javascript权威指南》学习笔记（6）/">《javascript权威指南》学习笔记（6）</a>
      </li>
    
      <li>
        <a href="/2016/05/26/黑魔法——纯css画一个三角形/">黑魔法——纯css画一个三角形</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/javascript学习笔记/">javascript学习笔记</a><small>8</small></li>
  
    <li><a href="/tags/哈哈哈！计划赶不上变化/">哈哈哈！计划赶不上变化</a><small>1</small></li>
  
    <li><a href="/tags/纯css实现多级nav/">纯css实现多级nav</a><small>1</small></li>
  
    <li><a href="/tags/纯css画三角形/">纯css画三角形</a><small>1</small></li>
  
    <li><a href="/tags/闭包和作用域/">闭包和作用域</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/javascript学习笔记/" style="font-size: 20px;">javascript学习笔记</a> <a href="/tags/哈哈哈！计划赶不上变化/" style="font-size: 10px;">哈哈哈！计划赶不上变化</a> <a href="/tags/纯css实现多级nav/" style="font-size: 10px;">纯css实现多级nav</a> <a href="/tags/纯css画三角形/" style="font-size: 10px;">纯css画三角形</a> <a href="/tags/闭包和作用域/" style="font-size: 10px;">闭包和作用域</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2016 D_d
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>