<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>D_d</title>
  <meta name="author" content="D_d" />

  
  <meta name="description" content="这里是丁丁的博客" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  
  <meta property="og:site_name" content="D_d" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  <link href="http://o6yoa3nwp.bkt.clouddn.com/favicon.ico" rel="icon" />
 

  <link rel="alternate" href="/atom.xml" title="D_d" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><br/><br/><br/><br/><br/><br/><br/>
<div class="alignleft1">
  <h1><a href="/">D_d</a></h1><br/>
  <h2><a href="/">——Welcome to D_d&#39;s Blog!——</a></h2><br/>
</div>
<nav id="main-nav" class="alignright1">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/">关于生活</a></li>
    
      <li><a href="/categories/technology">技术</a></li>
    
      <li><a href="/categories/technology/javascript">js</a></li>
    
      <li><a href="/categories/technology/css">HTML&amp;CSS</a></li>
    
      <li><a href="/categories/plan">哈哈哈计划赶不上变化</a></li>
    
  </ul>
</nav>
<br/><br/></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-12T13:27:45.000Z"><a href="/2016/07/12/工具小常识xampp-gulp/">2016-07-12</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/12/工具小常识xampp-gulp/">工具小常识xampp&amp;gulp</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="XAMPP"><a href="#XAMPP" class="headerlink" title="XAMPP"></a>XAMPP</h1><ul>
<li>修改Index指向的内容：<br>在安装目录下的htdocs文件夹下添加指向待添加项目文件夹的链接，注意这里并不是快捷方式，直接创建快捷方式会出错，要在cmd下使用mklink命令创建指向链接（直接在cmd下输入mklink会提示如何输参数）</li>
</ul>
<hr>
<h1 id="gulp的使用"><a href="#gulp的使用" class="headerlink" title="gulp的使用"></a>gulp的使用</h1><h3 id="一些git上使用的常用命令-安装npm的国内镜像cnpm可以加快速度"><a href="#一些git上使用的常用命令-安装npm的国内镜像cnpm可以加快速度" class="headerlink" title="一些git上使用的常用命令(安装npm的国内镜像cnpm可以加快速度)"></a>一些git上使用的常用命令(安装npm的国内镜像cnpm可以加快速度)</h3><ul>
<li>which gulp/cnmp检查是否安装过</li>
<li>在项目中首次使用gulp要初始化建立json配置文件（package.json），使用cnpm init命令</li>
<li>在项目中首次使用gulp要在项目中局部安装gulp，使用cnpm install gulp –save-dev命令，–save-dev表示在配置文件package.json中保存信息</li>
<li>vim gulpfile.js命令建立gulpfile.js文件并进入vim编辑器以编辑它,在该文件中写入gulp的功能</li>
<li>vim .gitignore命令建立.gitignore文件并进入vim编辑器以编辑它，在该文件中写入提交到仓库时需忽略的文件的相对路径</li>
<li>vim编辑器模式使用ctrl+c命令退出</li>
<li>gulp taskName命令执行写入的操作；也可以在gulpfile.js中定义default默认操作直接使用gulp命令执行一系列定义的操作，但其执行顺序不一定为定义顺序<h3 id="gulpfile-js中的命令"><a href="#gulpfile-js中的命令" class="headerlink" title="gulpfile.js中的命令"></a>gulpfile.js中的命令</h3></li>
<li>头部依赖<ul>
<li>var gulp= require(‘gulp’);</li>
<li>var minify-css= require(‘gulp-minify-css’);  //压缩css</li>
<li>var concat= require(‘gulp-concat’);  //拼接文件</li>
<li>var uglify= require(‘gulp-uglify’);  //压缩JS</li>
<li>var jshint= require(‘gulp-jshint’);  //语法检查</li>
</ul>
</li>
<li>常用函数<ul>
<li>gulp.task(name, fn)定义name任务</li>
<li>gulp.run(tasks…)尽可能多的并行运行多个task</li>
<li>gulp.watch(glob, fn)监听glob，当glob内容发生改变时，执行fn</li>
<li>gulp.src(glob)源文件路径，返回一个可读的stream</li>
<li>gulp.dest(glob)目标文件路径，返回一个可写的stream</li>
</ul>
</li>
<li>两个例子<ul>
<li>移动文件<pre><br>gulp.task(‘move’,function (){return gulp.src([‘../src/<em>*/</em>.<em>‘,’../src/</em>‘])    //src文件夹下所有文件夹下的所有文件及src下的所有文件夹（一个*只代表一层文件）<br>}).pipe(gulp.dest(‘./xxx’));    //pipe()表示进入管道流<br></pre></li>
<li>设置默认命令<pre><br>gulp.task(‘default’,function (){gulp.start([‘task1’,’task2’])});<br></pre><h3 id="最后要检查下移动后的文件数目与源文件数目是否相同！"><a href="#最后要检查下移动后的文件数目与源文件数目是否相同！" class="headerlink" title="最后要检查下移动后的文件数目与源文件数目是否相同！"></a>最后要检查下移动后的文件数目与源文件数目是否相同！</h3></li>
</ul>
</li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>, <a href="/categories/technology/javascript/日常的问题/">日常的问题</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/gulp/">gulp</a>, <a href="/tags/xampp/">xampp</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-09T02:30:25.000Z"><a href="/2016/07/09/《javascript权威指南》学习笔记（13）/">2016-07-09</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/09/《javascript权威指南》学习笔记（13）/">《javascript权威指南》学习笔记（13）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="canvas图形篇"><a href="#canvas图形篇" class="headerlink" title="canvas图形篇"></a>canvas图形篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<p>采用图形状态与绘制指令分离的思想，要定义画布宽高，单位默认为px<br>与svg的区别：canvas通过调用它提供的方法绘图，而svg是通过构建XML树实现，二者可相互模拟</p>
<p><div style="color:red;font-size:18px;"><br>绘制API大多定义在canvasRenderingContext2D对象上而不是&lt;canvas&gt;元素上，画布元素和上下文对象是分开的不同对象！每个&lt;canvas&gt;元素只有一个上下文对象！<br></div><br>例子：<pre><br>var canvas=document.getElementById(‘canvas’);  //画布对象<br>var c=canvas.getContext(‘2d’);  //上下文对象<br></pre></p>
<h3 id="线段与多边形API"><a href="#线段与多边形API" class="headerlink" title="线段与多边形API"></a>线段与多边形API</h3><ul>
<li>c.beginPath():开始定义新路径</li>
<li>c.lineTo(x,y):上次绘制终点与（x,y）点连线</li>
<li>c.closePath():连接终点与起点闭合路径</li>
<li>c.moveTo(x,y):开始新的子路径，（x,y）为起点<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3></li>
<li>rect(x,y,width,height):<span style="color:red;">会改变当前路径</span>添加该矩形到当前路径下，（x,y）为左上角顶点</li>
<li>fillRect(x,y,width,height)：<span style="color:red;">不改变当前路径</span>使用当前fillStyle填充矩形</li>
<li>strokeRect(x,y,width,height)：<span style="color:red;">不改变当前路径</span>使用当前strokeStyle填充矩形</li>
<li>clearRect(x,y,width,height):<span style="color:red;">不改变当前路径</span>忽略填充样式，采用透明黑色像素填充矩形，即显示空白<h3 id="图形属性"><a href="#图形属性" class="headerlink" title="图形属性"></a>图形属性</h3>不是传递给fill()与stroke()的参数，而是上下文对象的通用图形状态！是图形状态与绘制指令分离的思想！</li>
<li>c.fillStyle/c.strokeStyle:指定填充/勾勒时的颜色/图案/渐变</li>
<li>c.lineWidth:勾勒线宽，值为number类型，默认单位px</li>
<li>c.globalAlpha:绘制像素时的透明度，值在0~1之间，在原alpha的基础上乘以该值</li>
<li>c.textAlign/c.textBaseline:文本水平/垂直对齐方式</li>
<li>c.font：绘制文本时的CSS文字属性</li>
<li>c.shadowColor/c.shadowOffsetX/c.shadowOffsetY/c.shadowBlur:阴影属性</li>
<li>c.lineCap/c.lineJoin:线段端点/相交端点显示方式<br>c.fill()/c.stroke()后才会显示出来<h3 id="保存与恢复图形状态"><a href="#保存与恢复图形状态" class="headerlink" title="保存与恢复图形状态"></a>保存与恢复图形状态</h3></li>
<li>c.save()保存当前图形状态</li>
<li>c.restore()恢复原来的图形状态</li>
<li>Tips:<ul>
<li>可在多状态间切换</li>
<li>当前定义的路径及不属于图形状态的当前点不能保存/恢复<h3 id="坐标系变换"><a href="#坐标系变换" class="headerlink" title="坐标系变换"></a>坐标系变换</h3></li>
</ul>
</li>
<li>可通过c.translate()/c.rotate()/c.scale()实现坐标系变换<h3 id="曲线绘制"><a href="#曲线绘制" class="headerlink" title="曲线绘制"></a>曲线绘制</h3></li>
<li>c.arc(x,y,r,startAngle,endAngle,boolDerection):绘制圆心（x,y）,半径r,起始角度startAngle弧度,中止角度endAngle弧度,方向false为顺时针/true为逆时针的弧</li>
<li>c.arcTo(x1,y1,x2,y2,r):绘制与当前点到（x1,y1）及（x1,y1）到（x2,y2）的连线均相切且半径为r的弧<br>绘制圆角时使用较方便</li>
<li>c.bezierCurveTo()/c.quadraticCurveTo():绘制贝塞尔曲线<h3 id="勾勒与填充"><a href="#勾勒与填充" class="headerlink" title="勾勒与填充"></a>勾勒与填充</h3></li>
<li>纯色填充/勾勒：填充c.fillStyle=”rgb(2,8,90)/#f09”；勾勒c.strokeStyle=”#fff”</li>
<li>图案填充/勾勒：通过上下文对象的createPattern()方法<ul>
<li>c.fillStyle/strokeStyle=c.createPattern(“Element”,”repeat/repeat-x/repeat-y/no-repeat”):Element参数为&lt;img&gt;&lt;canvas&gt;&lt;video&gt;&lt;canvas&gt;或Image()构造函数创建的对象；第二个参数为重复方式</li>
</ul>
</li>
<li>渐变填充/勾勒：通过上下文对象的createLinear/RadialGradient()方法<ul>
<li>var chage=c.createLinearGradient(x1,y1,x2,y2);<br>(x1,y1)为渐变起点,(x2,y2)为渐变终点<br>(0,0,170,0)表示横向渐变，（0，0，0，50）标识竖向渐变，（0，0，50，50）表示对角渐变</li>
<li>var chage=c.createRadialGradient(x1,y1,r1,x2,y2,r2);<br>第二个圆要包含第一个圆，可不同心</li>
<li>change.addColorStop(0~1,’color’)：0~1表位置<br><span style="color:red;">添加渐变位置，至少有两处！</span></li>
</ul>
</li>
<li>调用c.fill()/c.stroke()方法实现指定样式的填充与勾勒</li>
<li>Tips:填充与勾勒均不改变路径！且不可用于阴影！<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3></li>
<li>c.font属性指定字体，字号等（同CSS的font复合属性）</li>
<li>c.fillStyle/c.strokeStyle指定填充/勾勒样式</li>
<li>还有c.textAlign/c.textBaseline属性</li>
<li>c.fillText(‘text’,x,y):填充（x,y）位置的text文本</li>
<li>c.strokeText(‘text’,x,y):勾勒（x,y）位置的text文本</li>
<li>c.measureText(‘text’).width:绘制文本前测量文本宽度<h3 id="线段绘制相关属性"><a href="#线段绘制相关属性" class="headerlink" title="线段绘制相关属性"></a>线段绘制相关属性</h3></li>
<li>c.lineCap:子路径端点连接方式，其可能值如下：<ul>
<li>butt:线段端点直接结束</li>
<li>square:端点再延长线段宽度的一半</li>
<li>round：端点再延长半径为线段宽度的一半半圆</li>
</ul>
</li>
<li>c.lineJoin:子路径相交顶点间连接方式，其可能值如下：<ul>
<li>miter：尖</li>
<li>round：圆</li>
<li>square：顶点处截断的方形<h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3></li>
</ul>
</li>
<li>c.clip():将当前路径定义为裁剪区域，该区域外不会绘制</li>
<li>每次调用只会缩小裁剪区域，不会放大，可在之前用c.save()保存当前图形，需要时用c.restore()恢复<h3 id="阴影-图形和渐变不用于阴影"><a href="#阴影-图形和渐变不用于阴影" class="headerlink" title="阴影(图形和渐变不用于阴影)"></a>阴影(图形和渐变不用于阴影)</h3></li>
<li>c.shadowColor：指定阴影颜色，默认全透明黑色</li>
<li>c.offsetX/c.offsetY:阴影X轴Y轴偏移，偏移越大阴影越大，值为number类型<br>偏移不受rotate()等坐标变换影响</li>
<li>c.shadowBlur:阴影模糊度，值越大越模糊，值为number类型</li>
<li>Tips:要使用c.fill()/c.stroke()填充/勾勒！<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3></li>
<li>c.drawImage(src,x,y,<del>width,height,desX,desY,desWidth,desHeight</del>):可传入3/5/9个参数<ul>
<li>3个参数：src为&lt;img&gt;&lt;video&gt;&lt;canvas&gt;或Image()构造函数创建的图片</li>
<li>5个参数：加上宽高</li>
<li>9个参数：将第2—5个参数的原矩形复制到第6—9个参数的目标矩形，此时坐标系为画布的坐标</li>
</ul>
</li>
<li>dcument.canvas.toDataURL():<span style="color:red;">这个方法不是上下文对象的，而是canvas标签的！</span>编码为图片URL字符串，有一个可选参数指定图片MIME类型如默认值image/png等，存在安全限制禁止跨域<h3 id="一个绘制多边形的例子"><a href="#一个绘制多边形的例子" class="headerlink" title="一个绘制多边形的例子"></a>一个绘制多边形的例子</h3>在（x,y）为中心r为半径的圆内绘制正n边形，其中c代表上下文对象<pre><br>function polygon(c,n,x,y,r){<br>var angle=2<em>MATH.PI/n; //n边形内角<br>c.beginPath();<br>c.moveTo(x+r</em>MATH.sin(angle),y-r<em>MATH.sin(angle));<br>for(var i=1;i&lt;n;i++){<br>var angleNow=(i+1)</em>angle;<br>c.lineTo(x+r<em>MATH.sin(angleNow),y-r</em>MATH.cos(angleNow))<br>}<br>c.closePath();<br>}<br></pre><br>这里只定义了路径，没有勾勒填充</li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-09T02:00:23.000Z"><a href="/2016/07/09/《javascript权威指南》学习笔记（12）/">2016-07-09</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/09/《javascript权威指南》学习笔记（12）/">《javascript权威指南》学习笔记（12）</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="SVG初级篇"><a href="#SVG初级篇" class="headerlink" title="SVG初级篇"></a>SVG初级篇</h3><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<p>SVG代表可伸缩的矢量图形，是一种用于描述图形的XML语法，IE9以下不支持。通过对画图形时的必要路径的精准的分辨率无关的描述实现绘图<br>早期使用&lt;object/&gt;插入svg图像，现在可以直接写入文档中</p>
<p><div style="color:red;font-size:18px;"><br>用JS创建svg图形时，使用XML语法，要使用createElementNS()处理DOM创建，直接用createElement()创建，显示时会出现问题<br></div><br>简单示例<pre><br>&lt;svg width=”15” height=”15”&gt;<br> &lt;rect x=”0” y=”0” width=”5” height=”5” fill=”red”/&gt;<br> &lt;circle cx=”7.5” cy=”7.5” r=”2.5” fill=”green”/&gt;<br> &lt;text x=”12.5” y=”12.5”&gt;D_d&lt;/text&gt;<br> &lt;line x1=”0” y1=”0” x2=”15” y2=”15”/&gt;<br> &lt;path d=”M0 0 L0 5 A15,15 0 0 0 7,7Z” stroke=”blue” stroke-width=”2”&gt;&lt;/path&gt;<br>&lt;/svg&gt;<br></pre><br>可配合transform实现动态效果</p>
<h3 id="一个SVG饼图的例子"><a href="#一个SVG饼图的例子" class="headerlink" title="一个SVG饼图的例子"></a>一个SVG饼图的例子</h3><p><pre><br>function pieChart(data,width,height,cx,cy,r,colors){<br>var svgns=’<a href="http://www.w3.org/2000/svg" target="_blank" rel="external">http://www.w3.org/2000/svg</a>‘;<br>var chart=document.createElementsNS(svgns,’svg:svg’); //创建&lt;svg&gt;元素<br>chart.setAttribute(‘width’,width);<br>chart.setAttribute(‘height’,height);<br>chart.setAttribute(‘viewBox’,’0 0’+width+’ ‘+height);<br>var angles=[];  //用以存储每个扇形对应的角度<br>var total=0;    //用以存储data的合计值<br>for(var i=0;i<data.length;i++) total+="data[i];" for(var="" i="0;i<data.length;i++)" angles[i]="data[i]/total*2*MATH.PI;" var="" startangle="0;" endangle="startAngle+angles[i];" 计算扇形和圆的相交点，12点方向为0度，顺时针方向为正方向="" x1="cx+r*MATH.sin(startAngle);" y1="cy-r*MATH.cos(startAngle);" x2="cx+r*MATH.sin(endAngle);" y2="cy-r*MATH.cos(endAngle);" 判断优弧与劣弧,优弧big值为1="" big="(endAngle-startAngle">MATH.PI)?1:0;<br> var path=document.createElementsNS(svgns,’path’);<br> var d=’M’+cx+’,’+cy+’ L’+x1+’,’+’y1’+’ A’+r+’,’+r+’ 0 ‘+big+’ 1 ‘+x2+’,’+’y2’+’ Z’;<br> path.setAttribute(‘d’,d);<br> path.setAttribute(‘fill’,colors[i]);<br> path.setAttribute(‘stroke’,’’black);<br> path.setAttribute(‘stroke-width’,’2’);<br> chart.appendChild(path);<br> }<br>}<br></data.length;i++)></pre><br>效果图如下：</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-08T10:10:26.000Z"><a href="/2016/07/08/《javascript权威指南》学习笔记（11）/">2016-07-08</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/08/《javascript权威指南》学习笔记（11）/">《javascript权威指南》学习笔记（11）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="多媒体篇"><a href="#多媒体篇" class="headerlink" title="多媒体篇"></a>多媒体篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<h3 id="缓存图片"><a href="#缓存图片" class="headerlink" title="缓存图片"></a>缓存图片</h3><ul>
<li>利用Image()构造函数创建一个屏幕外图片对象，将该对象的src属性置为期望的url，此时图片将添加至文档中，是不可见的，但浏览器还是会加载图片将其缓存。当图片加入文档中时才会显示。</li>
<li>一个例子:<pre>var img=new Image();
img.src='url';
document.body.appendChild(img);
</pre></li>
<li>Tips:同类构造函数还有Audio(),但无Video()构造函数<h3 id="脚本化的音频和视频"><a href="#脚本化的音频和视频" class="headerlink" title="脚本化的音频和视频"></a>脚本化的音频和视频</h3></li>
<li>设置src属性时，加载媒体的过程开始，若有其他媒体在load/play会中止这些媒体</li>
<li>H5引入&lt;audio&gt;&lt;video&gt;作为音频和视频元素（有control属性，置为true显示播放控件）</li>
<li>通常需要&lt;source&gt;指定不同格式媒体源，这是因为浏览器在对标准音频和视频解码器的支持上有差异<br>eg:&lt;source src=’music.ogg’&gt;<span style="color:red;">该标签无内容，不需闭合！</span></li>
<li>有Audio()构造函数支持音频缓存,但无Video()构造函数</li>
<li>一些属性与方法<ul>
<li>play()/pause():控制播放与暂停</li>
<li>canPlayType(‘媒体MIME类型,eg:audio/wav’):测试能否播放指定类型媒体文件，不能返回空值，可以返回</li>
<li>currentTime：单位秒，指定播放器应跳过播放的时间</li>
<li>volume:值在0~1之间，播放音量</li>
<li>muted：bool值，true为静音</li>
<li>controls,loop,preload,autoplay属性：也可做HTML属性，controls,loop,autoplay均为bool值，preload表示开始播放前是否预加载，加载多少内容，值为none不预加载/metadata元数据需加载（默认）/data预加载浏览器认为适量的内容</li>
<li>一些只读属性：用来查询bool值<ul>
<li>pause:是否暂停</li>
<li>seeking：是否跳至新播放点</li>
<li>initialTime：媒体开始时间，单位秒，一般为0</li>
<li>ended：是否播完</li>
<li>duration：媒体时长，单位秒</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-05T02:53:43.000Z"><a href="/2016/07/05/《javascript权威指南》学习笔记（10）/">2016-07-05</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/05/《javascript权威指南》学习笔记（10）/">《javascript权威指南》学习笔记（10）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="脚本化HTTP篇"><a href="#脚本化HTTP篇" class="headerlink" title="脚本化HTTP篇"></a>脚本化HTTP篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<p>HTTP：规定了Web浏览器如何从Web服务器获取文档，向Web服务器提交表单内容，Web服务器如何相应这些请求和提交（我的理解就是Web浏览器和服务器之间的交互）</p>
<h3 id="lt-img-gt-lt-script-gt-lt-iframe-gt-的src属性为url时会发起http的GET请求"><a href="#lt-img-gt-lt-script-gt-lt-iframe-gt-的src属性为url时会发起http的GET请求" class="headerlink" title="&lt;img&gt;,&lt;script&gt;,&lt;iframe&gt;的src属性为url时会发起http的GET请求"></a>&lt;img&gt;,&lt;script&gt;,&lt;iframe&gt;的src属性为url时会发起http的GET请求</h3><h3 id="Ajax特点："><a href="#Ajax特点：" class="headerlink" title="Ajax特点："></a>Ajax特点：</h3><p>使用脚本操纵HTTP和Web服务器进行数据交换，不会导致页面重载</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li>XMLHttpRequest对象不可跨域，通过JSONP实现跨域</li>
<li>P代表函数名包裹/填充数据，用JS函数包裹对应响应数据，一般函数名为callback</li>
<li>JSON表明服务器响应必须用JSON格式</li>
<li>XHR2可以通过选择合适的CORS（Cross-origin Resource Sharing）允许跨域，测试XHR.withCredentials可以判断浏览器是否支持<h3 id="JSONP原理"><a href="#JSONP原理" class="headerlink" title="JSONP原理"></a>JSONP原理</h3>&lt;script&gt;可以不受限于同源策略跨域通信，此时服务器响应采用JSON编码的数据格式，故这种Ajax传输协议叫做JSONP<br>Tips：只可用于处理GET请求<h3 id="XMLHttpRequest对象（实现Ajax技术）"><a href="#XMLHttpRequest对象（实现Ajax技术）" class="headerlink" title="XMLHttpRequest对象（实现Ajax技术）"></a>XMLHttpRequest对象（实现Ajax技术）</h3>定义了用脚本操纵Http的API，包含GET请求及POST请求的能力，能用文本或document对象的形式返回服务器响应<h3 id="与Ajax同类的Comet技术"><a href="#与Ajax同类的Comet技术" class="headerlink" title="与Ajax同类的Comet技术"></a>与Ajax同类的Comet技术</h3></li>
<li>在Comet中，web服务器发起通信并异步发送消息到客户端，若web应用需响应服务端，会使用Ajax技术发送、请求数据</li>
<li>Tips：Ajax中浏览器从服务器“拉”数据，Comet中服务器向浏览器“推”数据<h3 id="XMLHttpRequest对象实现Ajax请求"><a href="#XMLHttpRequest对象实现Ajax请求" class="headerlink" title="XMLHttpRequest对象实现Ajax请求"></a>XMLHttpRequest对象实现Ajax请求</h3>1.实例化XMLHttpRequest：var xhr=new XMLHttpRequest();<br>2.调用其open()方法：xhr.open(‘method’,’url’,<del>bool</del>);<ul>
<li>method参数为http请求方式，GET/POST，不区分大小写，但一般大写</li>
<li>url为请求地址，跨域会报错</li>
<li>bool为一个可选参数，是否异步，设为false会同步，但同步时send()会阻塞UI一般不用<br>3.若为POST方式需设置请求头以方便服务器正常解码：xhr.setRequestHeader(‘content-Type’,’xxx’);<br>４.监听readystate：<pre><br>xhr.onreadystatechange=function (){<br>if(xhr.readystate==4&amp;&amp;xhr.status==200){<br>//请求完成不一定成功，xhr.status==200才成功<br>response……<br>}<br>}</pre><br>5.向服务器发送可选请求体：xhr.send();</li>
</ul>
</li>
<li>这一步才会启动网络，发送请求</li>
<li>GET方式无请求体，POST方式有请求体,可携带请求体参数</li>
<li>发送请求后，会返回响应response<h3 id="XMLHttpRequest对象的响应"><a href="#XMLHttpRequest对象的响应" class="headerlink" title="XMLHttpRequest对象的响应"></a>XMLHttpRequest对象的响应</h3></li>
<li>完整的http响应由状态码，响应头，响应主体组成</li>
<li>响应返回后，有一系列响应属性生效。此时为在响应返回时得到通知，要监听readystate事件</li>
<li>响应属性如下：<ul>
<li>status/statusText：以数字/文本形式返回http状态码</li>
<li>responseText/responseXML：响应主体文本/Document形式</li>
<li>getResponseHeader()/getAllResponseHeader():查询响应头</li>
</ul>
</li>
<li>readystate属性：代表http请求状态<ul>
<li>0：open()未调用</li>
<li>1：open()以调用</li>
<li>2：收到响应头</li>
<li>3：收到响应体</li>
<li>4：响应完成</li>
<li>Tips:理论上每次改变都会触发事件，但实际上不同浏览器有差别0、1一般不触发，4所有浏览器都会触发<h3 id="http请求无法完成的触发事件"><a href="#http请求无法完成的触发事件" class="headerlink" title="http请求无法完成的触发事件"></a>http请求无法完成的触发事件</h3></li>
</ul>
</li>
<li>timeout：超时触发事件</li>
<li>abort：请求中止触发事件</li>
<li>error：重定向太多阻止请求触发事件<h3 id="中止请求"><a href="#中止请求" class="headerlink" title="中止请求"></a>中止请求</h3></li>
<li>如果用户在指定时间内还没有输入字符，应中止表单请求</li>
<li>abort()方法取消正在进行的HTTP请求<h3 id="编码请求主体"><a href="#编码请求主体" class="headerlink" title="编码请求主体"></a>编码请求主体</h3></li>
<li>url编码：<ul>
<li>POST方式提交表单要进行URL编码，即16进制转义码替换特殊字符，’=’分开名字和值，’&amp;’分开名值对</li>
<li>对表单数据有正式的请求头，’content-Type’为’application/x-www-form-unlencoded’</li>
<li>将名值对用encodeURIComponent(‘xxx’);编码</li>
</ul>
</li>
<li>JSON编码<ul>
<li>JSON.stringify(‘xxx’);编码</li>
<li>JSON.parse(‘xxx’);解码</li>
</ul>
</li>
<li>上传文件<ul>
<li>POST请求发送文件内容时，type=’file’时有files属性，它是File对象的类数组对象</li>
<li>XHR2允许在send()中传入File对象实现上传文件。文件类型为二进制大对象（Blob）的子类型</li>
</ul>
</li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-14T14:05:20.000Z"><a href="/2016/06/14/《javascript权威指南》学习笔记（9）/">2016-06-14</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/14/《javascript权威指南》学习笔记（9）/">《javascript权威指南》学习笔记（9）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="event事件对象篇"><a href="#event事件对象篇" class="headerlink" title="event事件对象篇"></a>event事件对象篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<p><div style="font-size:20px;">event代表事件状态，例如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态等</div></p>
<p><div style="color:red;font-size:20px;">event对象只在事件发生的过程中才有效！</div></p>
<h3 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h3><p><img src="http://o6yo3ducz.bkt.clouddn.com/event.jpg"></p>
<ul>
<li>事件是Web浏览器通知应用程序发生了什么事情</li>
<li>提及事件必须指明事件类型和目标<br>事件类型：说明发生了什么类型事件的字符串<br>时间目标：发生事件的对象或与之相关的对象</li>
<li>事件传播的三个阶段：<ul>
<li>捕获：目标处理程序调用之前，沿DOM树向下，从外向内捕获</li>
<li>目标对象本身的事件处理程序调用</li>
<li>冒泡：文档元素上发生某类型事件时会沿DOM树向上冒泡，当前DOM直到&lt;body&gt;,再到document，再到window<h3 id="注册事件处理程序"><a href="#注册事件处理程序" class="headerlink" title="注册事件处理程序"></a>注册事件处理程序</h3></li>
</ul>
</li>
<li><code>addEventListener(&#39;eventType&#39;,function,~~bool~~)</code>:三个参数为事件类型，发生时执行的函数，是否为捕获阶段（可省略，默认false）<br>IE9前使用<code>attachEvent(&#39;oneventType&#39;,function);</code>（tips:这里function中this指向window，<code>addEventListener()</code>中this指向事件目标）<br>可为同一事件注册多个函数，执行时会按注册顺序调用；<br>参数相同的情况下多次调用<code>addEventListener()</code>只注册一次</li>
<li>通过JS中对应属性设置：事件处理程序属性名称由”on”+”eventType”组成，全部小写</li>
<li>通过HTML属性设置：事件处理程序属性名称由”on”+”eventType”组成，全部小写。但为保持内容与行为分离，不应采用这种方式<h3 id="事件移除与取消"><a href="#事件移除与取消" class="headerlink" title="事件移除与取消"></a>事件移除与取消</h3></li>
<li>移除：<code>removeEventListener(&#39;eventType&#39;,function,~~bool~~)</code>参数必须和注册时相同</li>
<li>设置HTML属性注册事件处理程序，将返回值置为false，浏览器会取消默认行为，但这只对属性注册的程序有效</li>
<li>取消事件默认行为：<code>preventDefault()</code></li>
<li>阻止事件传播：<code>stopPropagation()</code>,可在传播期间任何时间调用<br>IE9以下不支持，通过将cancelBuble置为true阻止<h3 id="事件处理程序执行环境为其定义时的作用域，而不是调用时的作用域；但HTML属性中的事件处理程序会被转为能存取全局变量的顶级函数"><a href="#事件处理程序执行环境为其定义时的作用域，而不是调用时的作用域；但HTML属性中的事件处理程序会被转为能存取全局变量的顶级函数" class="headerlink" title="事件处理程序执行环境为其定义时的作用域，而不是调用时的作用域；但HTML属性中的事件处理程序会被转为能存取全局变量的顶级函数"></a>事件处理程序执行环境为其定义时的作用域，而不是调用时的作用域；但HTML属性中的事件处理程序会被转为能存取全局变量的顶级函数</h3><h3 id="事件处理程序的调用顺序"><a href="#事件处理程序的调用顺序" class="headerlink" title="事件处理程序的调用顺序"></a>事件处理程序的调用顺序</h3></li>
<li>通过JS对应属性及HTML属性注册的程序优先调用</li>
<li><code>addEventListener()</code>按注册顺序调用</li>
<li><code>attachEvent()</code>可能按任意顺序调用<h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3></li>
<li>三个阶段：捕获、事件处理程序调用、冒泡</li>
<li>当需要在大量单独的文档元素上注册处理程序时，可在其共同的祖先元素上注册</li>
<li>特殊冒泡行为：<ul>
<li>focus,blur,scroll不冒泡</li>
<li>load冒泡至document对象停止，文档全部加载完才会冒泡至window对象</li>
</ul>
</li>
<li>捕获常用于处理鼠标拖放，因为拖放目标不能是元素内部的子元素<h3 id="文档加载事件"><a href="#文档加载事件" class="headerlink" title="文档加载事件"></a>文档加载事件</h3></li>
<li>load:直到文档和所有图片加载完毕才发生（load发生前触发脚本可以提升web应用启动时间）</li>
<li>DOMContentLoaded：文档加载完毕且所有延迟脚本执行完毕触发</li>
<li>readystatechange：状态改变触发，在load事件前触发<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3></li>
<li>click：按下并释放鼠标按键时触发</li>
<li>contextmenu：单击鼠标右键上下文菜单即将出现时触发，可取消默认行为</li>
<li>dbclick：双击鼠标触发</li>
<li>mousedown：按下鼠标按键时触发</li>
<li>mouseup：释放鼠标按键时触发</li>
<li>mouseout：离开元素时触发（mouseleave为不冒泡的mouseout）</li>
<li>mouseover：进入元素悬停时触发（mouseenter为不冒泡的mouseover）</li>
<li>mousemove：移动鼠标时触发</li>
<li>tips：<br>传递给鼠标事件的event对象有clientX,clientY属性，指示鼠标位置的窗口坐标<br>event对象有altkey,ctrlkey,shiftkey,metakey等属性指定鼠标事件发生时该键有没有按下<h3 id="鼠标滚轮事件"><a href="#鼠标滚轮事件" class="headerlink" title="鼠标滚轮事件"></a>鼠标滚轮事件</h3></li>
<li>mousewheel:默认滚动或缩放文档，可阻止默认操作<br>传递给事件处理程序的事件对象event有wheelDelta属性，指定滚轮有多远<br>Firefox中用DOMMouseScroll取代mousewheel，用detail取代wheelDelta<h3 id="文本事件"><a href="#文本事件" class="headerlink" title="文本事件"></a>文本事件</h3></li>
<li>keydown:按下键盘（包括辅助键、功能键、字母数字键）</li>
<li>keypress:keydown产生可打印字符时，在keydown和keyup之间触发，文本真正插入前触发，表输入单个字符（可能需用string.fromCharCode()转为字符串才生效）</li>
<li>keyup:键盘释放（包括辅助键、功能键、字母数字键）</li>
<li>textinput：无论何时用户输入文本都会触发，不管来源（有兼容性问题）</li>
<li>相关event对象有keycode属性，指定按下的键是哪个<ul>
<li>可打印字符keycode值为unicode编码</li>
<li>字母键keycode值总为大写</li>
</ul>
</li>
<li>相关event对象有altkey,ctrlkey,shiftkey,metakey属性，事件发生时对应辅助键按下值为true<h3 id="事件处理程序定义时要传入参数e代表event对象！"><a href="#事件处理程序定义时要传入参数e代表event对象！" class="headerlink" title="事件处理程序定义时要传入参数e代表event对象！"></a>事件处理程序定义时要传入参数e代表event对象！</h3><h3 id="event对象的target属性：触发事件的元素（IE下为srcElement属性）"><a href="#event对象的target属性：触发事件的元素（IE下为srcElement属性）" class="headerlink" title="event对象的target属性：触发事件的元素（IE下为srcElement属性）"></a>event对象的target属性：触发事件的元素（IE下为srcElement属性）</h3><h3 id="event对象的currentTarget属性：事件绑定的节点"><a href="#event对象的currentTarget属性：事件绑定的节点" class="headerlink" title="event对象的currentTarget属性：事件绑定的节点"></a>event对象的currentTarget属性：事件绑定的节点</h3><h3 id="以上两者在事件委托时不同（事件委托-事件代理：利用事件会冒泡到父节点，通过父节点监听事件，再判断是父节点下哪个节点触发，做相应处理）"><a href="#以上两者在事件委托时不同（事件委托-事件代理：利用事件会冒泡到父节点，通过父节点监听事件，再判断是父节点下哪个节点触发，做相应处理）" class="headerlink" title="以上两者在事件委托时不同（事件委托/事件代理：利用事件会冒泡到父节点，通过父节点监听事件，再判断是父节点下哪个节点触发，做相应处理）"></a>以上两者在事件委托时不同（事件委托/事件代理：利用事件会冒泡到父节点，通过父节点监听事件，再判断是父节点下哪个节点触发，做相应处理）</h3>一个事件委托的例子：<pre><br>window.onload=function (){<br>var oUL=document.getElementById(‘ul’);<br>oUL.addEventListener(‘mouseover’,overFun,false);<br>oUL.addEventListener(‘mouseout’,outFun,false);<br>function overFun(e){<br>  var e=e||window.e;<br>  var target=e.target||e.srcElement  //兼容IE<br>  if(target.nodeName.toLowerCase()==’li’){<pre><code>target.style.background=&apos;red&apos;;
</code></pre>  }<br>}<br>function outFun(e){<pre><code>var e=e||window.e;
var target=e.target||e.srcElement  //兼容IE
if(target.nodeName.toLowerCase()==&apos;li&apos;){
  target.style.background=&apos;yellowgreen&apos;;
}
</code></pre>  }<br>}<br></pre></li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-14T14:05:11.000Z"><a href="/2016/06/14/《javascript权威指南》学习笔记（8）/">2016-06-14</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/14/《javascript权威指南》学习笔记（8）/">《javascript权威指南》学习笔记（8）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="脚本化CSS篇"><a href="#脚本化CSS篇" class="headerlink" title="脚本化CSS篇"></a>脚本化CSS篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<h3 id="一些CSS内容"><a href="#一些CSS内容" class="headerlink" title="一些CSS内容"></a>一些CSS内容</h3><ul>
<li>font复合属性：包括font-style,font-weight,font-variant,font-size/line-height,font-family;可忽略其中任意属性，不同属性空格分隔，同一属性的多值逗号分隔</li>
<li>text-transform:uppercase/lowercase/capitalize/none/inherit,设置文本大小写</li>
<li>box-sizing:border-box/content-box/inherit,宽高指定的范围</li>
<li>overflow:visible(溢出可绘制)/hidden(裁剪隐藏溢出)/scroll(一直显示滚动条，溢出滚动条查看)/auto(内容溢出时显示滚动条)</li>
<li><p>clip:裁剪绝对定位的元素（必有position:absolute!），值rect(top right bottom left)(矩形框中内容可见，左上角为基点)/auto(不剪裁)<br><img src="http://o6yo3ducz.bkt.clouddn.com/clip%E5%B1%9E%E6%80%A7rect%E7%A4%BA%E6%84%8F%E5%9B%BE.png" title="clip属性rect值示意图" width="290px"></p>
</li>
<li><p>透明度：opacity:0~1;为兼容IE设置filter:alpha(opacity=0~100)</p>
</li>
<li>CSS3有支持计算的属性：cal(val)，但存在一些兼容性问题，eg:<code>width:cal(50%-12px);</code></li>
<li>对已定位元素，只设置left，right可隐性指定宽度，但同时设置left，width，right不合理时，width会覆盖right（top,height,bottom同理，但一般不指定高度，由内容撑起）</li>
<li>对定位而言，left,top基于左上角定位，bottom,right基于右下角定位，指容器border内侧到定位元素border外侧的距离</li>
<li>z-index相当于z轴维度，默认为0，可正可负，正显示于文档流之上，负显示于文档流之下，值越大越靠上，相同值按文档流次序显示；只对有定位元素生效，无定位（position:static）元素无效，<span style="red">且只对兄弟元素应用堆叠效果</span></li>
<li>通过@font-face可下载并使用自定义字体</li>
<li>text-shadow,box-shadow属性可用position,left,top,z-index:-1,background-color等属性模拟<h3 id="脚本化的CSS（xxx-style-xxx更改的为内联样式，即直接在HTML元素的style属性下更改）"><a href="#脚本化的CSS（xxx-style-xxx更改的为内联样式，即直接在HTML元素的style属性下更改）" class="headerlink" title="脚本化的CSS（xxx.style.xxx更改的为内联样式，即直接在HTML元素的style属性下更改）"></a>脚本化的CSS（xxx.style.xxx更改的为内联样式，即直接在HTML元素的style属性下更改）</h3></li>
<li>JS中style属性的值本质为一个CSSStyleDeclaration对象，形式为字符串形式</li>
<li>含连字符的属性在JS的脚本化CSS中要去掉连字符，连字符间的单词首字母要大写，eg:font-weight-&gt;fontWeight<br>Float为JS保留字，采用CSSFloat代替；class为JS保留字，用className代替</li>
<li>定位属性的值在脚本化CSS中要包含px等单位</li>
<li>xxx.style.cssText可以查询<strong>内联样式</strong></li>
<li>HTML元素有方法<code>setAttribute（&#39;attr&#39;,&#39;value&#39;）</code>和<code>getAttribute（&#39;attr&#39;）</code>用来设置和获取属性</li>
<li>计算样式：是一组属性值，经过结合内联样式和链接样式等中所有可用样式得到显示时实际所用的属性值<br>只读，不可写；值为非百分比的绝对值；不计算复合样式；<br>使用：<code>window.getComputedStyle(element,null/&#39;:after&#39;/&#39;:firstline&#39;…);</code></li>
<li>H5定义了classList属性，解决多类名问题。其中有add(),remove()等方法添加删除类名；还有contains()检测是否包含类名；及toggle()不存在则添加存在则删除类名；</li>
<li>document.stylesheets:只读类数组对象，包括&lt;link&gt;和&lt;style&gt;下的样式表<br><span style="color:red;">有disable属性，值为true会被浏览器忽略</span><br><code>document.stylesheets[i].cssRules[]</code>对象包含样式表所有规则，IE中为<code>document.stylesheets[i].Rules[]</code></li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-06T14:09:42.000Z"><a href="/2016/06/06/《javascript权威指南》学习笔记（7）/">2016-06-06</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/06/《javascript权威指南》学习笔记（7）/">《javascript权威指南》学习笔记（7）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="document对象篇"><a href="#document对象篇" class="headerlink" title="document对象篇"></a>document对象篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<h3 id="window对象的document属性引用了Document对象，document对象表示窗口的内容，它是一个巨大的API中的核心对象，叫做文档对象模型（Document-Object-Model）"><a href="#window对象的document属性引用了Document对象，document对象表示窗口的内容，它是一个巨大的API中的核心对象，叫做文档对象模型（Document-Object-Model）" class="headerlink" title="window对象的document属性引用了Document对象，document对象表示窗口的内容，它是一个巨大的API中的核心对象，叫做文档对象模型（Document Object Model）"></a>window对象的document属性引用了Document对象，document对象表示窗口的内容，它是一个巨大的API中的核心对象，叫做文档对象模型（Document Object Model）</h3><h3 id="选取文档元素"><a href="#选取文档元素" class="headerlink" title="选取文档元素"></a>选取文档元素</h3><ul>
<li>通过ID：<code>document.getElementById(&#39;xxx&#39;)</code></li>
<li>通过CSS类：<code>document.getElementsByClassName(&#39;xxx&#39;)</code>，返回同类名的NodeList对象，可传入多个类名以空格分隔，具体到选中某一个使用<code>document.getElementsByClassName(&#39;xxx&#39;)[i]</code></li>
<li>通过标签名：<code>document.getElementsByTagName(&#39;xxx&#39;)[i]</code>，可传入星号通配符’*’</li>
<li>通过名字：<code>document.getElementsByName(&#39;xxx&#39;)[i]</code>（name属性只在少数HTML中有效，如：表单元素、&lt;img&gt;、&lt;iframe&gt;）</li>
<li>通过CSS选择器：借助querySelectorAll方法<h3 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h3>Document对象的Element对象和文档中表示文本的Text对象都是Node对象，Node对象有以下重要属性</li>
<li>作为节点树：<ul>
<li>parentNode：当前节点的父节点</li>
<li>childNodes:子节点，类数组对象，NodeList对象，具体到某个子节点childNodes[i]</li>
<li>firstChild,lastChild:第一个/最后一个子节点（无返回Null）eg：&lt;p&gt;123&lt;这里<code>document.getElementByTagName(&#39;p&#39;)[0].firstChild</code>为Text节点</li>
<li>nextSibling，previousSibling:下一个/上一个兄弟节点(使用时注意每两个节点间有一个空节点)</li>
<li>length：节点长度（如;Node.childNodes.length）</li>
<li>nodeType：节点类型（9为document节点，1为Element节点…Text节点为无标签的文字节点，comment节点为注释节点）</li>
<li>nodeValue：文本内容</li>
<li>nodeName：返回大写形式的元素标签名</li>
</ul>
</li>
<li>作为元素树：<ul>
<li>firstElementChild,lastElementChild:代表Element的首个子节点/最后一个子节点</li>
<li>nextElementSibling，previousElementSibling:代表兄弟Element</li>
<li>children:子Element</li>
<li>childElementCount:子Element数量<h3 id="HTML元素属性（HTML属性名大、小写不敏感，但JS属性名大、小写敏感）"><a href="#HTML元素属性（HTML属性名大、小写不敏感，但JS属性名大、小写敏感）" class="headerlink" title="HTML元素属性（HTML属性名大、小写不敏感，但JS属性名大、小写敏感）"></a>HTML元素属性（HTML属性名大、小写不敏感，但JS属性名大、小写敏感）</h3></li>
</ul>
</li>
<li>数据集属性：这里非标准属性，使用的代价是文档不再为合法有效的HTML，针对这点，H5解决方案为：以”data-“为前缀的小写属性是合法的，使用dataset属性设定（dataset.x对应data-x），这样不会在合法性上让步<ul>
<li><code>Node.getAttribute(&#39;xxx&#39;)</code>:查询非标准HTML属性，这里返回字符串，若需要数值类型要强制转换</li>
<li><code>Node.setAttribute(&#39;attribute&#39;,&#39;value&#39;)</code>:设置非标准HTML属性</li>
<li><code>Node.hasAttribute(&#39;xxx&#39;)</code>:判断属性名是否存在</li>
<li><code>Node.removeAttribute(&#39;xxx&#39;)</code>:删除属性</li>
</ul>
</li>
<li>Element对象有attributes类数组，eg:<code>Element.attributes[i]</code>/<code>Element.attributes.width</code>/<code>Element.attributes[onload]</code><h3 id="元素的内容"><a href="#元素的内容" class="headerlink" title="元素的内容"></a>元素的内容</h3></li>
<li>Element的innerHTML返回元素的内容（通常innerHTML效率非常高，但用‘+=’追加文本效率低下，因为它既要序列化又要解析）</li>
<li>H5有outerHTML属性，返回被查询元素的开头和结尾标签（存在一些兼容性问题）</li>
<li>textContent：不适于IE，返回返回所有后代Text节点的串联纯文本<br>innerText：只适用于IE，返回纯文本内容，不返回&lt;script&gt;下内容会忽略多余空格<h3 id="创建、插入、删除节点"><a href="#创建、插入、删除节点" class="headerlink" title="创建、插入、删除节点"></a>创建、插入、删除节点</h3></li>
<li>创建：<ul>
<li><code>document.createElement(&#39;标签名&#39;);</code></li>
<li><code>document.createTextNode(&#39;content&#39;)</code>:创建Text节点；</li>
<li><code>Node.cloneNode(bool)</code>:true为复制所有后代节点；false为浅复制（默认）</li>
</ul>
</li>
<li>插入节点：<ul>
<li><code>Node.appendChild(a)</code>:将a节点插入为Node节点的最后一个子节点</li>
<li><code>Node.insertBefore(new,old)</code>:<span style="color:red">Node为待插入节点的父节点，在父节点上调用该方法！</span>在old节点前插入New节点</li>
<li>Tips:<span style="color:red">将文档中已存在的节点重新插入，会自动从当前位置删除该节点并在新位置插入！</span></li>
</ul>
</li>
<li>删除节点：<ul>
<li><code>Node.removeChild(a)</code>:在Node节点上删除其子节点a</li>
<li><code>Node.replaceChild(new,old)</code>:<span style="color:red">Node为待替换节点的父节点，在父节点上调用该方法！</span>以new节点代替old节点</li>
</ul>
</li>
<li>DocumentFragment:<ul>
<li>一种特殊的Node，类似于文档片段，使一组节点被当做一个节点看待，创建并插入多节点时性能更佳，它是独立的，不是其他任何文档的一部分，其ParentNode为Null，可以有任意多子节点</li>
<li>创建：<code>document.createDocumentFragment()</code></li>
<li>插入和删除采用<code>appendChild(a)</code>，<code>insertBefore(new,old)</code>，<code>removeChild(a)</code>，<code>replaceChild(new,old)</code>，<span style="color:red">操作的是DocumentFragment的子孙节点</span><h3 id="窗口坐标（元素位置以像素度量，右为X轴正向，下为Y轴正向）"><a href="#窗口坐标（元素位置以像素度量，右为X轴正向，下为Y轴正向）" class="headerlink" title="窗口坐标（元素位置以像素度量，右为X轴正向，下为Y轴正向）"></a>窗口坐标（元素位置以像素度量，右为X轴正向，下为Y轴正向）</h3></li>
</ul>
</li>
<li>文档坐标：原点为文档左上角<br>视口坐标（窗口坐标）：原点为不包括工具栏的浏览器窗口左上角（通常查询到的坐标为视口坐标）<br>二者相差滚动条偏移量（window对象的pageXoffset,pageYoffset返回滚动条偏移量，<body>节点或文档根节点document.documentElement的scrollTop,scrollLeft返回滚动条偏移量）</body></li>
<li>元素的尺寸、位置坐标(HTML元素的属性)<ul>
<li>offset前缀：对内联元素会生效<ul>
<li>offsetWidth,offsetHeight：包括border,padding,content的元素宽高</li>
<li>offsetLeft,offsetTop：文档坐标，基点为文档左上角，但对于已定位元素后代，会基于祖先元素定位</li>
<li>offsetParent：已定位元素相对的父元素</li>
</ul>
</li>
<li>client前缀：对内联元素总为0<ul>
<li>clientWidth,clientHeight:包括padding,content的元素宽高</li>
<li>clientLeft,clientTop:padding外边距到border内边距的距离，一般为border宽度，除非左或上有滚动条会包含滚动条宽度</li>
</ul>
</li>
<li>scroll前缀：<ul>
<li>scrollWidth,scrollHeight:包括padding,content的元素宽高，若有溢出内容包括溢出内容的宽高</li>
<li>scrollLeft,scrollTop:滚动条偏移量</li>
</ul>
</li>
</ul>
</li>
<li>滚动条<ul>
<li>window对象下，<code>scrollTo(x,y)</code>:滚动至(x,y)坐标处</li>
<li>window对象下，<code>scrollBy(x,y)</code>:相对参数，在当前滚动条基础上增加</li>
</ul>
</li>
<li>查询元素的几何尺寸<ul>
<li><code>element.getBoundingClientRect()</code>:无参数，返回一个对象，其left,top为左上角坐标，right,bottom为右下角坐标</li>
<li>Tips:该方法不是实时的，仅为当前静态情况</li>
</ul>
</li>
<li>window对象的innerWidth,innerHeight返回不含工具栏但包括滚动条的页面宽高<h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3></li>
<li>可通过<code>document.forms[i]</code>/<code>document.forms.elements[i]</code>访问</li>
<li>JS的Form对象有<code>submit()</code>和<code>reset()</code>方法，直接调用不会触发onsubmit,onreset事件</li>
<li>对onsubmit,onreset事件处理程序，可通过false取消动作，借此检查用户输入</li>
<li>下拉列表和下拉框<ul>
<li>&lt;select&gt;的type属性有单选select-one/多选select-multiple值，当multiple属性存在时，值为select-multiple</li>
<li>&lt;select&gt;的selectedIndex属性：返回被选中选项（若type为select-multiple失效）</li>
<li>通过options[i]的text,value属性返回对应文本内容及值</li>
<li>指定options.length会截断列表元素（大于length值的元素会被删除），options[i]=null;会删除当前元素并使后续元素移动填补空缺</li>
<li>添加列表元素可通过以下方式：（传统创建插入方式同样有效）<br><code>var a=new Option(&#39;text&#39;,&#39;value&#39;,defaultSelected,selected);</code>//后两个参数为布尔值<br><code>options[options.length]=a;</code><h3 id="查询选中的内容"><a href="#查询选中的内容" class="headerlink" title="查询选中的内容"></a>查询选中的内容</h3></li>
</ul>
</li>
<li><code>window.getselection()</code>方法可返回选中文本，但对&lt;textarea&gt;和&lt;input&gt;内部的文本会失效<h3 id="可编辑内容（以下存在兼容性问题，需要用一些编辑器组件）"><a href="#可编辑内容（以下存在兼容性问题，需要用一些编辑器组件）" class="headerlink" title="可编辑内容（以下存在兼容性问题，需要用一些编辑器组件）"></a>可编辑内容（以下存在兼容性问题，需要用一些编辑器组件）</h3></li>
<li>HTML元素有contentEditable属性使内容可编辑</li>
<li>Document有designMode属性，值为on可编辑，值为off不可编辑<h3 id="document-write-方法"><a href="#document-write-方法" class="headerlink" title="document.write()方法"></a><code>document.write()</code>方法</h3></li>
<li>解析文档时可用<code>document.write()</code>方法，可以在&lt;script&gt;顶层代码中调用<code>document.write()</code></li>
<li>若定义函数时没有调用而在事件处理程序中调用含<code>document.write()</code>的函数，结果可能会擦除当前文档</li>
<li>在defer和async属性存在的&lt;script&gt;中也不可调用</li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-06T03:25:10.000Z"><a href="/2016/06/06/《javascript权威指南》学习笔记（6）/">2016-06-06</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/06/《javascript权威指南》学习笔记（6）/">《javascript权威指南》学习笔记（6）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="window对象篇"><a href="#window对象篇" class="headerlink" title="window对象篇"></a>window对象篇</h1><p><img src="http://o6yo3ducz.bkt.clouddn.com/javascript-book-cover.jpg" title="javascript权威指南" width="200px"></p>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><ul>
<li><code>setInterval(function,time)</code>,<code>clearInterval(some-setInterval)</code>:每隔time<strong>毫秒</strong>重复执行function,clearInterval为清除计时器</li>
<li><code>setTimeout(function,time)</code>,<code>clearTimeout(some-setTimeout)</code>:指定time<strong>毫秒</strong>后执行function(只执行一次),clearTimeout为清除计时器</li>
<li>Tips:<ul>
<li>设定计时器时传入的参数function不必调用，指定时间会自动调用；若传入了调用的function会每次都返回执行的结果！！！</li>
<li>setTimeout中时间延迟指定为0ms不会立即执行函数，会将其排队，等待前面的事件处理程序执行完后立即执行！！！<br>例子：<pre>/&lowast;<br>&lowast;函数f()的调用模式<br>&lowast;start毫秒后调用f()函数<br>&lowast;若设置了interval没有设置end函数会无限循环调用<br>&lowast;若设置了interval和end函数会在interval时间内重复调用<br>&lowast;若没有设置interval和end函数会只调用一次<br>&lowast;start缺省值为0ms<br>&lowast;/<br>function invoke(f,start,interval,end){<br>if(!start){start=0;}<br>if(arguments.length&lt;3){setTimeout(f,start);}<br>else{<pre><code>  setTimeout(repeat,start);
  function repeat(){
    var h=setInterval(f,interval);
    if(end){setTimeout(function (){clearInterval(h);},end);}
}
</code></pre>}<br>}<br></pre><h3 id="window对象的location属性-引用location对象-：表示该窗口中当前显示的文档的URL"><a href="#window对象的location属性-引用location对象-：表示该窗口中当前显示的文档的URL" class="headerlink" title="window对象的location属性(引用location对象)：表示该窗口中当前显示的文档的URL"></a>window对象的location属性(引用location对象)：表示该窗口中当前显示的文档的URL</h3></li>
</ul>
</li>
<li>location对象的href属性是一个字符串，值为当前文档的url(可以通过改变location.href实现页面跳转)；location对象的toString()方法会返回href属性的值（隐式调用toString()方法时可用location代替location.href）</li>
<li>location的其他属性，代表url的各个部分，均返回字符串（包括protocol,host,hostname,port,pathname,search等）<br>其中search属性返回问号之后的url，一般代表查询字段（可通过结合substring(start,end)方法取得参数，此处要用decodeURIComponent对其进行解码）</li>
<li>location对象的方法：<ul>
<li><code>location.assign（&quot;url&quot;）</code>:窗口载入并显示url</li>
<li><code>location.replace（&quot;url&quot;）</code>:窗口载入并显示url,载入前会从历史记录中删除当前文档，使后退操作无法回到当前</li>
<li><code>location.reload（）</code>:无参数，重新载入当前页面</li>
</ul>
</li>
<li>Tips:不存在锚点#top，location.href=’#top’也可回到顶部（<a>标签中同理）<h3 id="window对象的history属性-引用history对象-：表示当前窗口的历史记录"><a href="#window对象的history属性-引用history对象-：表示当前窗口的历史记录" class="headerlink" title="window对象的history属性(引用history对象)：表示当前窗口的历史记录"></a>window对象的history属性(引用history对象)：表示当前窗口的历史记录</h3></a></li>
<li>history.length:浏览历史列表中的元素数量</li>
<li>history对象的方法：<ul>
<li><code>history.back()</code>:无参数，回退一次</li>
<li><code>history.forward()</code>:无参数，前进一次</li>
<li><code>history.go(times)</code>:参数可正可负，正代表前进times次，负代表后退times次</li>
</ul>
</li>
<li>Tips:若窗口中包含&lt;iframe&gt;，其中的记录会穿插在历史记录中，后退前进操作可能会导致子窗口生效，主窗口无效<h3 id="window对象的navigator属性-引用navigator对象-：表示浏览器信息"><a href="#window对象的navigator属性-引用navigator对象-：表示浏览器信息" class="headerlink" title="window对象的navigator属性(引用navigator对象)：表示浏览器信息"></a>window对象的navigator属性(引用navigator对象)：表示浏览器信息</h3>这里navigator的名字是为纪念Netscape navigator浏览器</li>
<li>navigator的属性:<ul>
<li>navigator.appName:除IE不同，其他均为Netscape</li>
<li>navigator.appVersion:版本信息</li>
<li>navigator.userAgent:http头部发送的user-agent字符串</li>
<li>navigator.platform:浏览器的操作系统</li>
<li>其他属性还有onLine,geolocation,cookieEnable等等<h3 id="window对象的screen属性-引用screen对象-：表示屏幕信息，大小、颜色数量等"><a href="#window对象的screen属性-引用screen对象-：表示屏幕信息，大小、颜色数量等" class="headerlink" title="window对象的screen属性(引用screen对象)：表示屏幕信息，大小、颜色数量等"></a>window对象的screen属性(引用screen对象)：表示屏幕信息，大小、颜色数量等</h3></li>
</ul>
</li>
<li>screen.width/screen.height:像素为单位的窗口大小</li>
<li>screen.availWidth/screen.availHeight:实际可用的窗口大小</li>
<li>colorDepth:显示的BPP值（16,24,32…）<h3 id="对话框（会阻塞当前代码，用户体验不好）"><a href="#对话框（会阻塞当前代码，用户体验不好）" class="headerlink" title="对话框（会阻塞当前代码，用户体验不好）"></a>对话框（会阻塞当前代码，用户体验不好）</h3></li>
<li><code>alert(&#39;information&#39;)</code>:提示消息</li>
<li><code>confirm(&#39;information&#39;)</code>:确认信息，返回布尔值</li>
<li><code>prompt(&#39;information&#39;)</code>:用户输入框</li>
<li><code>showModalDialog(&#39;url&#39;,包含标题的内容（数组/对象），style内容如：&quot;dialogWidth;resizable=yes;&quot;等)</code>:模拟对话框<h3 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h3></li>
<li>一般通过try/catch捕获抛出错误，过去采用window.onerror事件<h3 id="HTML元素中使用值为非保留值的id属性时，其值会成为可以被脚本访问的全局变量（name属性不会这样；且name属性可重复，id属性必须唯一）"><a href="#HTML元素中使用值为非保留值的id属性时，其值会成为可以被脚本访问的全局变量（name属性不会这样；且name属性可重复，id属性必须唯一）" class="headerlink" title="HTML元素中使用值为非保留值的id属性时，其值会成为可以被脚本访问的全局变量（name属性不会这样；且name属性可重复，id属性必须唯一）"></a>HTML元素中使用值为非保留值的id属性时，其值会成为可以被脚本访问的全局变量（name属性不会这样；且name属性可重复，id属性必须唯一）</h3><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3></li>
<li>一个web窗口包含多个标签页，每个标签页都是独立的浏览上下文，每个上下文都有独立的window对象，相互之间互不干扰</li>
<li>打开：<code>window.open(&#39;url&#39;~~,name,style,bool~~)</code>:省略url会打开空白页；name已存在会指向该页面，不存在会以此命名新窗口；bool在name为已存在生效，是否替换当前历史记录，默认false</li>
<li>关闭：<code>window.close()</code>:显示指定window,避免与document.close()混淆</li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/javascript/">javascript</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/javascript学习笔记/">javascript学习笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-26T14:13:26.000Z"><a href="/2016/05/26/黑魔法——纯css画一个三角形/">2016-05-26</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/26/黑魔法——纯css画一个三角形/">黑魔法——纯css画一个三角形</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="今天看《CSS设计指南（第3版）》的时候发现了一个神奇黑魔法，居然可以用纯css画出一个三角形，感觉好神奇！"><a href="#今天看《CSS设计指南（第3版）》的时候发现了一个神奇黑魔法，居然可以用纯css画出一个三角形，感觉好神奇！" class="headerlink" title="今天看《CSS设计指南（第3版）》的时候发现了一个神奇黑魔法，居然可以用纯css画出一个三角形，感觉好神奇！"></a>今天看《CSS设计指南（第3版）》的时候发现了一个神奇黑魔法，居然可以用纯css画出一个三角形，感觉好神奇！</h3><h3 id="原理是令盒模型宽高都为0，再通过border边框把三个边置为透明，只留一个有色边框即为所需三角形，如图所示。可在需要添加三角形的地方以-after或-before伪元素添加，这个例子就是这样。"><a href="#原理是令盒模型宽高都为0，再通过border边框把三个边置为透明，只留一个有色边框即为所需三角形，如图所示。可在需要添加三角形的地方以-after或-before伪元素添加，这个例子就是这样。" class="headerlink" title="原理是令盒模型宽高都为0，再通过border边框把三个边置为透明，只留一个有色边框即为所需三角形，如图所示。可在需要添加三角形的地方以::after或::before伪元素添加，这个例子就是这样。"></a>原理是令盒模型宽高都为0，再通过border边框把三个边置为透明，只留一个有色边框即为所需三角形，如图所示。可在需要添加三角形的地方以<code>::after</code>或<code>::before</code>伪元素添加，这个例子就是这样。</h3><p><img src="http://o6yo3ducz.bkt.clouddn.com/triangleTheory.png" alt="三角形的原理图"></p>
<p><pre style="font-size:20px;">CSS代码<br>.triangle:after {<br>            content: “”;        //content为必填属性<br>            border: 12px solid;<br>            //通过border边框把三个边置为透明，只留一个有色边框即为所需三角形，这里是红色三角形<br>            border-color: transparent red transparent transparent;<br>            height: 0;         //高必须为0<br>            width: 0;          //宽必须为0<br>            display: block;    //必须以block方式显示<br>        }<br></pre></p>
<h3 id="HTML部分只需-lt-div-class-”triangle”-gt-lt-div-gt-即可显示一个三角形"><a href="#HTML部分只需-lt-div-class-”triangle”-gt-lt-div-gt-即可显示一个三角形" class="headerlink" title="HTML部分只需&lt;div class=”triangle”&gt;&lt;/div&gt;即可显示一个三角形~~~"></a>HTML部分只需&lt;div class=”triangle”&gt;&lt;/div&gt;即可显示一个三角形~~~</h3>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/technology/">technology</a>, <a href="/categories/technology/css/">css</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/纯css画三角形/">纯css画三角形</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  <div class="widget tag">
  <h3 class="title">关于 wo</h3>
  <ul class="entry">
    <li style="padding-left: 40px;"><img width="150px" src="http://o6yoa3nwp.bkt.clouddn.com/me.jpg" title="头像"/></li>
    <br/><hr/><br/>
    <li>丁丁</li>
    <li>双子座</li>
    <li>爱生活，爱技术，爱旅行，爱摄影</li><br/><hr/><br/>
    <li style="text-align: center;"><a target="_blank" href="http://weibo.com/u/2258194143?refer_flag=1001030102_&is_all=1">go to 我的微博</a></li>
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/technology/css/">css</a><small>2</small></li>
  
    <li><a href="/categories/technology/javascript/">javascript</a><small>15</small></li>
  
    <li><a href="/categories/plan/">plan</a><small>1</small></li>
  
    <li><a href="/categories/technology/">technology</a><small>17</small></li>
  
    <li><a href="/categories/technology/javascript/日常的问题/">日常的问题</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/07/12/工具小常识xampp-gulp/">工具小常识xampp&amp;gulp</a>
      </li>
    
      <li>
        <a href="/2016/07/09/《javascript权威指南》学习笔记（13）/">《javascript权威指南》学习笔记（13）</a>
      </li>
    
      <li>
        <a href="/2016/07/09/《javascript权威指南》学习笔记（12）/">《javascript权威指南》学习笔记（12）</a>
      </li>
    
      <li>
        <a href="/2016/07/08/《javascript权威指南》学习笔记（11）/">《javascript权威指南》学习笔记（11）</a>
      </li>
    
      <li>
        <a href="/2016/07/05/《javascript权威指南》学习笔记（10）/">《javascript权威指南》学习笔记（10）</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/gulp/">gulp</a><small>1</small></li>
  
    <li><a href="/tags/javascript学习笔记/">javascript学习笔记</a><small>13</small></li>
  
    <li><a href="/tags/xampp/">xampp</a><small>1</small></li>
  
    <li><a href="/tags/哈哈哈！计划赶不上变化/">哈哈哈！计划赶不上变化</a><small>1</small></li>
  
    <li><a href="/tags/纯css实现多级nav/">纯css实现多级nav</a><small>1</small></li>
  
    <li><a href="/tags/纯css画三角形/">纯css画三角形</a><small>1</small></li>
  
    <li><a href="/tags/闭包和作用域/">闭包和作用域</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/gulp/" style="font-size: 10px;">gulp</a> <a href="/tags/javascript学习笔记/" style="font-size: 20px;">javascript学习笔记</a> <a href="/tags/xampp/" style="font-size: 10px;">xampp</a> <a href="/tags/哈哈哈！计划赶不上变化/" style="font-size: 10px;">哈哈哈！计划赶不上变化</a> <a href="/tags/纯css实现多级nav/" style="font-size: 10px;">纯css实现多级nav</a> <a href="/tags/纯css画三角形/" style="font-size: 10px;">纯css画三角形</a> <a href="/tags/闭包和作用域/" style="font-size: 10px;">闭包和作用域</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2016 D_d
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>